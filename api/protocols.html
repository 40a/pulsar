<!DOCTYPE html>



<html>
<head>
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

    <title>Protocols/Transports API &mdash; pulsar 0.8.0-beta.2 documentation</title>
    
    <link rel="stylesheet" href="../static/pulsar.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.8.0-beta.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <link rel="shortcut icon" href="../static/favicon.ico"/>
    <link rel="top" title="pulsar 0.8.0-beta.2 documentation" href="../index.html" />
    <link rel="up" title="API" href="index.html" />
    <link rel="next" title="Application API" href="application.html" />
    <link rel="prev" title="Event API" href="events.html" /> 
</head>
 <body>



    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="application.html" title="Application API"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="events.html" title="Event API"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">pulsar 0.8.0-beta.2 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">API</a> &raquo;</li> 
      </ul>
    </div>
<div class="deck">
<div class="header">
    
        <p class="developmentversion">
        Documentation for pulsar's DEVELOPMENT version. Get the
        <a href="http://pythonhosted.org/pulsar/api/protocols.html">release docs here</a>.
        </p>
    
</div>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="protocols-transports-api">
<span id="protocol-api"></span><h1>Protocols/Transports API<a class="headerlink" href="#protocols-transports-api" title="Permalink to this headline">¶</a></h1>
<p>This part of the <a class="reference internal" href="index.html#api"><em>pulsar API</em></a> is about classes responsible for
implementing the Protocol/Transport paradigm. <a class="reference internal" href="#pulsar.async.internet.SocketTransport" title="pulsar.async.internet.SocketTransport"><tt class="xref py py-class docutils literal"><span class="pre">SocketTransport</span></tt></a>
and <a class="reference internal" href="#pulsar.async.protocols.Protocol" title="pulsar.async.protocols.Protocol"><tt class="xref py py-class docutils literal"><span class="pre">Protocol</span></tt></a> are designed to comply with <a class="reference external" href="http://www.python.org/dev/peps/pep-3156/">pep-3156</a> specification
and derived from <tt class="docutils literal"><span class="pre">asyncio.Transport</span></tt> and <tt class="docutils literal"><span class="pre">asyncio.Protocol</span></tt>.</p>
<div class="admonition note" id="eventloop-class">
<p class="first admonition-title">Note</p>
<p><strong>Event Loop classes</strong></p>
<p class="last">An event-loop class create objects with the <tt class="docutils literal"><span class="pre">_loop</span></tt>
attribute which is the <tt class="docutils literal"><span class="pre">asincio.eventloop</span></tt> controlling the event-loop
object.</p>
</div>
<div class="section" id="transports">
<h2>Transports<a class="headerlink" href="#transports" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#pulsar.async.internet.SocketTransport" title="pulsar.async.internet.SocketTransport"><tt class="xref py py-class docutils literal"><span class="pre">SocketTransport</span></tt></a> is used as base class for all socket transports
and it is the only class in this section which is also used outside
TCP sockets.</p>
<div class="section" id="sockettransport">
<h3>SocketTransport<a class="headerlink" href="#sockettransport" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pulsar.async.internet.SocketTransport">
<em class="property">class </em><tt class="descclassname">pulsar.async.internet.</tt><tt class="descname">SocketTransport</tt><big>(</big><em>loop</em>, <em>sock</em>, <em>protocol</em>, <em>extra=None</em>, <em>max_buffer_size=None</em>, <em>read_chunk_size=None</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/internet.html#SocketTransport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.internet.SocketTransport" title="Permalink to this definition">¶</a></dt>
<dd><p>An <tt class="docutils literal"><span class="pre">asyncio.Transport</span></tt> for sockets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>loop</strong> &#8211; Set the <tt class="xref py py-attr docutils literal"><span class="pre">_loop</span></tt> attribute.</li>
<li><strong>sock</strong> &#8211; Set the <tt class="xref py py-attr docutils literal"><span class="pre">_sock</span></tt> attribute.</li>
<li><strong>protocol</strong> &#8211; set the <tt class="xref py py-attr docutils literal"><span class="pre">_protocol</span></tt> attribute.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pulsar.async.internet.SocketTransport.SocketError">
<tt class="descname">SocketError</tt><a class="headerlink" href="#pulsar.async.internet.SocketTransport.SocketError" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">OSError</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.async.internet.SocketTransport.sock">
<tt class="descname">sock</tt><a class="reference internal" href="../modules/pulsar/async/internet.html#SocketTransport.sock"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.internet.SocketTransport.sock" title="Permalink to this definition">¶</a></dt>
<dd><p>The socket for this transport.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.async.internet.SocketTransport.closing">
<tt class="descname">closing</tt><a class="reference internal" href="../modules/pulsar/async/internet.html#SocketTransport.closing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.internet.SocketTransport.closing" title="Permalink to this definition">¶</a></dt>
<dd><p>The transport is about to close. In this state the transport is not
listening for <tt class="docutils literal"><span class="pre">read</span></tt> events but it may still be writing, unless it
is <tt class="xref py py-attr docutils literal"><span class="pre">closed</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.async.internet.SocketTransport.closed">
<tt class="descname">closed</tt><a class="reference internal" href="../modules/pulsar/async/internet.html#SocketTransport.closed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.internet.SocketTransport.closed" title="Permalink to this definition">¶</a></dt>
<dd><p>The transport is closed. No read/write operation available.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.async.internet.SocketTransport.protocol">
<tt class="descname">protocol</tt><a class="reference internal" href="../modules/pulsar/async/internet.html#SocketTransport.protocol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.internet.SocketTransport.protocol" title="Permalink to this definition">¶</a></dt>
<dd><p>The protocol for this socket transport.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.internet.SocketTransport.close">
<tt class="descname">close</tt><big>(</big><em>async=True</em>, <em>exc=None</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/internet.html#SocketTransport.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.internet.SocketTransport.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Closes the transport.</p>
<p>Buffered data will be flushed asynchronously.  No more data
will be received.  After all buffered data is flushed, the
<tt class="xref py py-attr docutils literal"><span class="pre">protocol</span></tt> <tt class="docutils literal"><span class="pre">connection_lost</span></tt> method will (eventually) called
with <tt class="docutils literal"><span class="pre">exc</span></tt> as its argument.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.internet.SocketTransport.abort">
<tt class="descname">abort</tt><big>(</big><em>exc=None</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/internet.html#SocketTransport.abort"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.internet.SocketTransport.abort" title="Permalink to this definition">¶</a></dt>
<dd><p>Closes the transport immediately.</p>
<p>Buffered data will be lost. No more data will be received.
The <tt class="xref py py-attr docutils literal"><span class="pre">protocol</span></tt> <tt class="docutils literal"><span class="pre">connection_lost</span></tt> method will (eventually) be
called with <tt class="docutils literal"><span class="pre">exc</span></tt> as its argument.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-pulsar.async.stream"></span></div>
<div class="section" id="socketstreamtransport">
<h3>SocketStreamTransport<a class="headerlink" href="#socketstreamtransport" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pulsar.async.stream.SocketStreamTransport">
<em class="property">class </em><tt class="descclassname">pulsar.async.stream.</tt><tt class="descname">SocketStreamTransport</tt><big>(</big><em>loop</em>, <em>sock</em>, <em>protocol</em>, <em>extra=None</em>, <em>max_buffer_size=None</em>, <em>read_chunk_size=None</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/stream.html#SocketStreamTransport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.stream.SocketStreamTransport" title="Permalink to this definition">¶</a></dt>
<dd><p>A <tt class="xref py py-class docutils literal"><span class="pre">pulsar.SocketTransport</span></tt> for TCP streams.</p>
<p>The primary feature of a stream transport is sending bytes to a protocol
and receiving bytes from the underlying protocol. Writing to the transport
is done using the <a class="reference internal" href="#pulsar.async.stream.SocketStreamTransport.write" title="pulsar.async.stream.SocketStreamTransport.write"><tt class="xref py py-meth docutils literal"><span class="pre">write()</span></tt></a> and <a class="reference internal" href="#pulsar.async.stream.SocketStreamTransport.writelines" title="pulsar.async.stream.SocketStreamTransport.writelines"><tt class="xref py py-meth docutils literal"><span class="pre">writelines()</span></tt></a> methods.
The latter method is a performance optimisation, to allow software to take
advantage of specific capabilities in some transport mechanisms.</p>
<dl class="method">
<dt id="pulsar.async.stream.SocketStreamTransport.pause_reading">
<tt class="descname">pause_reading</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pulsar/async/stream.html#SocketStreamTransport.pause_reading"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.stream.SocketStreamTransport.pause_reading" title="Permalink to this definition">¶</a></dt>
<dd><p>Suspend delivery of data to the protocol until a subsequent
<a class="reference internal" href="#pulsar.async.stream.SocketStreamTransport.resume_reading" title="pulsar.async.stream.SocketStreamTransport.resume_reading"><tt class="xref py py-meth docutils literal"><span class="pre">resume_reading()</span></tt></a> call.</p>
<p>Between <a class="reference internal" href="#pulsar.async.stream.SocketStreamTransport.pause_reading" title="pulsar.async.stream.SocketStreamTransport.pause_reading"><tt class="xref py py-meth docutils literal"><span class="pre">pause_reading()</span></tt></a> and <a class="reference internal" href="#pulsar.async.stream.SocketStreamTransport.resume_reading" title="pulsar.async.stream.SocketStreamTransport.resume_reading"><tt class="xref py py-meth docutils literal"><span class="pre">resume_reading()</span></tt></a>, the
protocol&#8217;s data_received() method will not be called.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.stream.SocketStreamTransport.resume_reading">
<tt class="descname">resume_reading</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pulsar/async/stream.html#SocketStreamTransport.resume_reading"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.stream.SocketStreamTransport.resume_reading" title="Permalink to this definition">¶</a></dt>
<dd><p>Resume the receiving end.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.stream.SocketStreamTransport.write">
<tt class="descname">write</tt><big>(</big><em>data</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/stream.html#SocketStreamTransport.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.stream.SocketStreamTransport.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write chunk of <tt class="docutils literal"><span class="pre">data</span></tt> to the end-point.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.stream.SocketStreamTransport.writelines">
<tt class="descname">writelines</tt><big>(</big><em>list_of_data</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/stream.html#SocketStreamTransport.writelines"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.stream.SocketStreamTransport.writelines" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a list (or any iterable) of data bytes to the transport.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="socketstreamssltransport">
<h3>SocketStreamSslTransport<a class="headerlink" href="#socketstreamssltransport" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pulsar.async.stream.SocketStreamSslTransport">
<em class="property">class </em><tt class="descclassname">pulsar.async.stream.</tt><tt class="descname">SocketStreamSslTransport</tt><big>(</big><em>loop</em>, <em>rawsock</em>, <em>protocol</em>, <em>sslcontext</em>, <em>server_side=True</em>, <em>server_hostname=None</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/stream.html#SocketStreamSslTransport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.stream.SocketStreamSslTransport" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="#pulsar.async.stream.SocketStreamTransport" title="pulsar.async.stream.SocketStreamTransport"><tt class="xref py py-class docutils literal"><span class="pre">SocketStreamTransport</span></tt></a> with Transport Layer Security</p>
<dl class="attribute">
<dt id="pulsar.async.stream.SocketStreamSslTransport.rawsock">
<tt class="descname">rawsock</tt><a class="reference internal" href="../modules/pulsar/async/stream.html#SocketStreamSslTransport.rawsock"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.stream.SocketStreamSslTransport.rawsock" title="Permalink to this definition">¶</a></dt>
<dd><p>The raw socket.</p>
<p>This is the socket not wrapped by the sslcontext.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-pulsar.async.protocols"></span></div>
</div>
<div class="section" id="protocols">
<h2>Protocols<a class="headerlink" href="#protocols" title="Permalink to this headline">¶</a></h2>
<div class="section" id="protocol">
<h3>Protocol<a class="headerlink" href="#protocol" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pulsar.async.protocols.Protocol">
<em class="property">class </em><tt class="descclassname">pulsar.async.protocols.</tt><tt class="descname">Protocol</tt><big>(</big><em>session=1</em>, <em>producer=None</em>, <em>timeout=0</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#Protocol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.Protocol" title="Permalink to this definition">¶</a></dt>
<dd><p>An <tt class="docutils literal"><span class="pre">asyncio.Protocol</span></tt> for a <a class="reference internal" href="#pulsar.async.stream.SocketStreamTransport" title="pulsar.async.stream.SocketStreamTransport"><tt class="xref py py-class docutils literal"><span class="pre">SocketStreamTransport</span></tt></a>.</p>
<p>A <a class="reference internal" href="#pulsar.async.protocols.Protocol" title="pulsar.async.protocols.Protocol"><tt class="xref py py-class docutils literal"><span class="pre">Protocol</span></tt></a> is an <a class="reference internal" href="events.html#pulsar.async.events.EventHandler" title="pulsar.async.events.EventHandler"><tt class="xref py py-class docutils literal"><span class="pre">EventHandler</span></tt></a> which has
two <a class="reference internal" href="../tutorials/events.html#one-time-event"><em>one time events</em></a>:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">connection_made</span></tt></li>
<li><tt class="docutils literal"><span class="pre">connection_lost</span></tt></li>
</ul>
<dl class="attribute">
<dt id="pulsar.async.protocols.Protocol.session">
<tt class="descname">session</tt><a class="reference internal" href="../modules/pulsar/async/protocols.html#Protocol.session"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.Protocol.session" title="Permalink to this definition">¶</a></dt>
<dd><p>Connection session number.</p>
<p>Passed during initialisation by the <a class="reference internal" href="#pulsar.async.protocols.Protocol.producer" title="pulsar.async.protocols.Protocol.producer"><tt class="xref py py-attr docutils literal"><span class="pre">producer</span></tt></a>.
Usually an integer representing the number of separate connections
the producer has processed at the time it created this
<a class="reference internal" href="#pulsar.async.protocols.Protocol" title="pulsar.async.protocols.Protocol"><tt class="xref py py-class docutils literal"><span class="pre">Protocol</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.async.protocols.Protocol.transport">
<tt class="descname">transport</tt><a class="reference internal" href="../modules/pulsar/async/protocols.html#Protocol.transport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.Protocol.transport" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pulsar.async.stream.SocketStreamTransport" title="pulsar.async.stream.SocketStreamTransport"><tt class="xref py py-class docutils literal"><span class="pre">SocketStreamTransport</span></tt></a> for this connection.</p>
<p>Available once the <a class="reference internal" href="#pulsar.async.protocols.Protocol.connection_made" title="pulsar.async.protocols.Protocol.connection_made"><tt class="xref py py-meth docutils literal"><span class="pre">connection_made()</span></tt></a> is called.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.async.protocols.Protocol.sock">
<tt class="descname">sock</tt><a class="reference internal" href="../modules/pulsar/async/protocols.html#Protocol.sock"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.Protocol.sock" title="Permalink to this definition">¶</a></dt>
<dd><p>The socket of <a class="reference internal" href="#pulsar.async.protocols.Protocol.transport" title="pulsar.async.protocols.Protocol.transport"><tt class="xref py py-attr docutils literal"><span class="pre">transport</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.async.protocols.Protocol.address">
<tt class="descname">address</tt><a class="reference internal" href="../modules/pulsar/async/protocols.html#Protocol.address"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.Protocol.address" title="Permalink to this definition">¶</a></dt>
<dd><p>The address of the <a class="reference internal" href="#pulsar.async.protocols.Protocol.transport" title="pulsar.async.protocols.Protocol.transport"><tt class="xref py py-attr docutils literal"><span class="pre">transport</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.async.protocols.Protocol.timeout">
<tt class="descname">timeout</tt><a class="reference internal" href="../modules/pulsar/async/protocols.html#Protocol.timeout"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.Protocol.timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of seconds to keep alive this connection when idle.</p>
<p>A value of <tt class="docutils literal"><span class="pre">0</span></tt> means no timeout.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.async.protocols.Protocol.producer">
<tt class="descname">producer</tt><a class="reference internal" href="../modules/pulsar/async/protocols.html#Protocol.producer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.Protocol.producer" title="Permalink to this definition">¶</a></dt>
<dd><p>The producer of this <a class="reference internal" href="#pulsar.async.protocols.Protocol" title="pulsar.async.protocols.Protocol"><tt class="xref py py-class docutils literal"><span class="pre">Protocol</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.async.protocols.Protocol.closed">
<tt class="descname">closed</tt><a class="reference internal" href="../modules/pulsar/async/protocols.html#Protocol.closed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.Protocol.closed" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">True</span></tt> if the <a class="reference internal" href="#pulsar.async.protocols.Protocol.transport" title="pulsar.async.protocols.Protocol.transport"><tt class="xref py py-attr docutils literal"><span class="pre">transport</span></tt></a> is closed.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.protocols.Protocol.close">
<tt class="descname">close</tt><big>(</big><em>async=True</em>, <em>exc=None</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#Protocol.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.Protocol.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close by closing the <a class="reference internal" href="#pulsar.async.protocols.Protocol.transport" title="pulsar.async.protocols.Protocol.transport"><tt class="xref py py-attr docutils literal"><span class="pre">transport</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.protocols.Protocol.abort">
<tt class="descname">abort</tt><big>(</big><em>exc=None</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#Protocol.abort"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.Protocol.abort" title="Permalink to this definition">¶</a></dt>
<dd><p>Abort by aborting the <a class="reference internal" href="#pulsar.async.protocols.Protocol.transport" title="pulsar.async.protocols.Protocol.transport"><tt class="xref py py-attr docutils literal"><span class="pre">transport</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.protocols.Protocol.connection_made">
<tt class="descname">connection_made</tt><big>(</big><em>transport</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#Protocol.connection_made"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.Protocol.connection_made" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the transport, fire the <tt class="docutils literal"><span class="pre">connection_made</span></tt> event and adds
a <a class="reference internal" href="#pulsar.async.protocols.Protocol.timeout" title="pulsar.async.protocols.Protocol.timeout"><tt class="xref py py-attr docutils literal"><span class="pre">timeout</span></tt></a> for idle connections.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.protocols.Protocol.connection_lost">
<tt class="descname">connection_lost</tt><big>(</big><em>exc=None</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#Protocol.connection_lost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.Protocol.connection_lost" title="Permalink to this definition">¶</a></dt>
<dd><p>Fires the <tt class="docutils literal"><span class="pre">connection_lost</span></tt> event.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.protocols.Protocol.eof_received">
<tt class="descname">eof_received</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#Protocol.eof_received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.Protocol.eof_received" title="Permalink to this definition">¶</a></dt>
<dd><p>The socket was closed from the remote end</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.protocols.Protocol.set_timeout">
<tt class="descname">set_timeout</tt><big>(</big><em>timeout</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#Protocol.set_timeout"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.Protocol.set_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a new <a class="reference internal" href="#pulsar.async.protocols.Protocol.timeout" title="pulsar.async.protocols.Protocol.timeout"><tt class="xref py py-attr docutils literal"><span class="pre">timeout</span></tt></a> for this connection.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="connection">
<h3>Connection<a class="headerlink" href="#connection" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pulsar.async.protocols.Connection">
<em class="property">class </em><tt class="descclassname">pulsar.async.protocols.</tt><tt class="descname">Connection</tt><big>(</big><em>consumer_factory=None</em>, <em>**kw</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#Connection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.Connection" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="#pulsar.async.protocols.Protocol" title="pulsar.async.protocols.Protocol"><tt class="xref py py-class docutils literal"><span class="pre">Protocol</span></tt></a> to handle multiple request/response.</p>
<p>It is a class which acts as bridge between a
<a class="reference internal" href="#pulsar.async.stream.SocketStreamTransport" title="pulsar.async.stream.SocketStreamTransport"><tt class="xref py py-class docutils literal"><span class="pre">SocketStreamTransport</span></tt></a>
and a <a class="reference internal" href="#pulsar.async.protocols.ProtocolConsumer" title="pulsar.async.protocols.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a>. It routes data arriving from the
<a class="reference internal" href="#pulsar.async.stream.SocketStreamTransport" title="pulsar.async.stream.SocketStreamTransport"><tt class="xref py py-class docutils literal"><span class="pre">SocketStreamTransport</span></tt></a> to the <a class="reference internal" href="#pulsar.async.protocols.Connection.current_consumer" title="pulsar.async.protocols.Connection.current_consumer"><tt class="xref py py-meth docutils literal"><span class="pre">current_consumer()</span></tt></a>.</p>
<dl class="attribute">
<dt id="pulsar.async.protocols.Connection._consumer_factory">
<tt class="descname">_consumer_factory</tt><a class="headerlink" href="#pulsar.async.protocols.Connection._consumer_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>A factory of <a class="reference internal" href="#pulsar.async.protocols.ProtocolConsumer" title="pulsar.async.protocols.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.async.protocols.Connection._processed">
<tt class="descname">_processed</tt><a class="headerlink" href="#pulsar.async.protocols.Connection._processed" title="Permalink to this definition">¶</a></dt>
<dd><p>number of separate requests processed.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.protocols.Connection.current_consumer">
<tt class="descname">current_consumer</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#Connection.current_consumer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.Connection.current_consumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pulsar.async.protocols.ProtocolConsumer" title="pulsar.async.protocols.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> currently handling incoming data.</p>
<p>This instance will receive data when this connection get data
from the <a class="reference internal" href="#pulsar.async.protocols.Protocol.transport" title="pulsar.async.protocols.Protocol.transport"><tt class="xref py py-attr docutils literal"><span class="pre">transport</span></tt></a> via the <a class="reference internal" href="#pulsar.async.protocols.Connection.data_received" title="pulsar.async.protocols.Connection.data_received"><tt class="xref py py-meth docutils literal"><span class="pre">data_received()</span></tt></a>
method.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.protocols.Connection.data_received">
<tt class="descname">data_received</tt><big>(</big><em>data</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#Connection.data_received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.Connection.data_received" title="Permalink to this definition">¶</a></dt>
<dd><p>Delegates handling of data to the <a class="reference internal" href="#pulsar.async.protocols.Connection.current_consumer" title="pulsar.async.protocols.Connection.current_consumer"><tt class="xref py py-meth docutils literal"><span class="pre">current_consumer()</span></tt></a>.</p>
<p>Once done set a timeout for idle connections when a
<a class="reference internal" href="#pulsar.async.protocols.Protocol.timeout" title="pulsar.async.protocols.Protocol.timeout"><tt class="xref py py-attr docutils literal"><span class="pre">timeout</span></tt></a> is a positive number (of seconds).</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.protocols.Connection.connection_lost">
<tt class="descname">connection_lost</tt><big>(</big><em>exc</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#Connection.connection_lost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.Connection.connection_lost" title="Permalink to this definition">¶</a></dt>
<dd><p>It performs these actions in the following order:</p>
<ul class="simple">
<li>Fires the <tt class="docutils literal"><span class="pre">connection_lost</span></tt> <a class="reference internal" href="../tutorials/events.html#one-time-event"><em>one time event</em></a>
if not fired before, with <tt class="docutils literal"><span class="pre">exc</span></tt> as event data.</li>
<li>Cancel the idle timeout if set.</li>
<li>Invokes the <a class="reference internal" href="#pulsar.async.protocols.ProtocolConsumer.connection_lost" title="pulsar.async.protocols.ProtocolConsumer.connection_lost"><tt class="xref py py-meth docutils literal"><span class="pre">ProtocolConsumer.connection_lost()</span></tt></a> method in the
<a class="reference internal" href="#pulsar.async.protocols.Connection.current_consumer" title="pulsar.async.protocols.Connection.current_consumer"><tt class="xref py py-meth docutils literal"><span class="pre">current_consumer()</span></tt></a>.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.protocols.Connection.upgrade">
<tt class="descname">upgrade</tt><big>(</big><em>consumer_factory</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#Connection.upgrade"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.Connection.upgrade" title="Permalink to this definition">¶</a></dt>
<dd><p>Upgrade the <a class="reference internal" href="#pulsar.async.protocols.Connection._consumer_factory" title="pulsar.async.protocols.Connection._consumer_factory"><tt class="xref py py-func docutils literal"><span class="pre">_consumer_factory()</span></tt></a> callable.</p>
<p>This method can be used when the protocol specification changes
during a response (an example is a WebSocket request/response,
or HTTP tunneling).</p>
<p>This method adds a <tt class="docutils literal"><span class="pre">post_request</span></tt> callback to the
<a class="reference internal" href="#pulsar.async.protocols.Connection.current_consumer" title="pulsar.async.protocols.Connection.current_consumer"><tt class="xref py py-meth docutils literal"><span class="pre">current_consumer()</span></tt></a> to build a new consumer with the new
<a class="reference internal" href="#pulsar.async.protocols.Connection._consumer_factory" title="pulsar.async.protocols.Connection._consumer_factory"><tt class="xref py py-func docutils literal"><span class="pre">_consumer_factory()</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>consumer_factory</strong> &#8211; the new consumer factory (a callable
accepting no parameters)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal"><span class="pre">None</span></tt>.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="protocol-consumer">
<h3>Protocol Consumer<a class="headerlink" href="#protocol-consumer" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pulsar.async.protocols.ProtocolConsumer">
<em class="property">class </em><tt class="descclassname">pulsar.async.protocols.</tt><tt class="descname">ProtocolConsumer</tt><big>(</big><em>loop=None</em>, <em>one_time_events=None</em>, <em>many_times_events=None</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#ProtocolConsumer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.ProtocolConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The consumer of data for a server or client <a class="reference internal" href="#pulsar.async.protocols.Connection" title="pulsar.async.protocols.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a>.</p>
<p>It is responsible for receiving incoming data from an end point via the
<a class="reference internal" href="#pulsar.async.protocols.Connection.data_received" title="pulsar.async.protocols.Connection.data_received"><tt class="xref py py-meth docutils literal"><span class="pre">Connection.data_received()</span></tt></a> method, decoding (parsing) and,
possibly, writing back to the client or server via
the <a class="reference internal" href="#pulsar.async.protocols.ProtocolConsumer.transport" title="pulsar.async.protocols.ProtocolConsumer.transport"><tt class="xref py py-attr docutils literal"><span class="pre">transport</span></tt></a> attribute.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For server consumers, <a class="reference internal" href="#pulsar.async.protocols.ProtocolConsumer.data_received" title="pulsar.async.protocols.ProtocolConsumer.data_received"><tt class="xref py py-meth docutils literal"><span class="pre">data_received()</span></tt></a> is the only method
to implement.
For client consumers, <a class="reference internal" href="#pulsar.async.protocols.ProtocolConsumer.start_request" title="pulsar.async.protocols.ProtocolConsumer.start_request"><tt class="xref py py-meth docutils literal"><span class="pre">start_request()</span></tt></a> should also be implemented.</p>
</div>
<p>A <a class="reference internal" href="#pulsar.async.protocols.ProtocolConsumer" title="pulsar.async.protocols.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> is a subclass of <tt class="xref py py-class docutils literal"><span class="pre">EventHandler</span></tt> and it
has two default <a class="reference internal" href="../tutorials/events.html#one-time-event"><em>one time events</em></a>:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">pre_request</span></tt> fired when the request is received (for servers) or
just before is sent (for clients).
This occurs just before the <a class="reference internal" href="#pulsar.async.protocols.ProtocolConsumer.start_request" title="pulsar.async.protocols.ProtocolConsumer.start_request"><tt class="xref py py-meth docutils literal"><span class="pre">start_request()</span></tt></a> method.</li>
<li><tt class="docutils literal"><span class="pre">post_request</span></tt> fired when the request is done. The
<a class="reference internal" href="#pulsar.async.protocols.ProtocolConsumer.on_finished" title="pulsar.async.protocols.ProtocolConsumer.on_finished"><tt class="xref py py-attr docutils literal"><span class="pre">on_finished</span></tt></a> attribute is the
<tt class="xref py py-class docutils literal"><span class="pre">Deferred</span></tt> called back once this event occurs.</li>
</ul>
<p>In addition, it has two <a class="reference internal" href="../tutorials/events.html#many-times-event"><em>many times events</em></a>:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">data_received</span></tt> fired when new data is received from the transport but
not yet processed (before the <a class="reference internal" href="#pulsar.async.protocols.ProtocolConsumer.data_received" title="pulsar.async.protocols.ProtocolConsumer.data_received"><tt class="xref py py-meth docutils literal"><span class="pre">data_received()</span></tt></a> method is invoked)</li>
<li><tt class="docutils literal"><span class="pre">data_processed</span></tt> fired just after data has been consumed (after the
<a class="reference internal" href="#pulsar.async.protocols.ProtocolConsumer.data_received" title="pulsar.async.protocols.ProtocolConsumer.data_received"><tt class="xref py py-meth docutils literal"><span class="pre">data_received()</span></tt></a> method)</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A useful example on how to use the <tt class="docutils literal"><span class="pre">data_received</span></tt> event is
the <a class="reference internal" href="../tutorials/proxy.html#tutorials-proxy-server"><em>wsgi proxy server</em></a>.</p>
</div>
<dl class="attribute">
<dt id="pulsar.async.protocols.ProtocolConsumer.connection">
<tt class="descname">connection</tt><a class="reference internal" href="../modules/pulsar/async/protocols.html#ProtocolConsumer.connection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.ProtocolConsumer.connection" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pulsar.async.protocols.Connection" title="pulsar.async.protocols.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> of this consumer.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.async.protocols.ProtocolConsumer.request">
<tt class="descname">request</tt><a class="reference internal" href="../modules/pulsar/async/protocols.html#ProtocolConsumer.request"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.ProtocolConsumer.request" title="Permalink to this definition">¶</a></dt>
<dd><p>The request.</p>
<p>Used for clients only and available only after the
<a class="reference internal" href="#pulsar.async.protocols.ProtocolConsumer.start" title="pulsar.async.protocols.ProtocolConsumer.start"><tt class="xref py py-meth docutils literal"><span class="pre">start()</span></tt></a> method is invoked.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.async.protocols.ProtocolConsumer.transport">
<tt class="descname">transport</tt><a class="reference internal" href="../modules/pulsar/async/protocols.html#ProtocolConsumer.transport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.ProtocolConsumer.transport" title="Permalink to this definition">¶</a></dt>
<dd><p>The <tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt> of this consumer</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.async.protocols.ProtocolConsumer.producer">
<tt class="descname">producer</tt><a class="reference internal" href="../modules/pulsar/async/protocols.html#ProtocolConsumer.producer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.ProtocolConsumer.producer" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pulsar.async.protocols.Producer" title="pulsar.async.protocols.Producer"><tt class="xref py py-class docutils literal"><span class="pre">Producer</span></tt></a> of this consumer.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.async.protocols.ProtocolConsumer.on_finished">
<tt class="descname">on_finished</tt><a class="reference internal" href="../modules/pulsar/async/protocols.html#ProtocolConsumer.on_finished"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.ProtocolConsumer.on_finished" title="Permalink to this definition">¶</a></dt>
<dd><p>The <tt class="docutils literal"><span class="pre">post_request</span></tt> one time event.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.protocols.ProtocolConsumer.connection_made">
<tt class="descname">connection_made</tt><big>(</big><em>connection</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#ProtocolConsumer.connection_made"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.ProtocolConsumer.connection_made" title="Permalink to this definition">¶</a></dt>
<dd><p>Called by a <a class="reference internal" href="#pulsar.async.protocols.Connection" title="pulsar.async.protocols.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> when it starts using this consumer.</p>
<p>By default it does nothing.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.protocols.ProtocolConsumer.data_received">
<tt class="descname">data_received</tt><big>(</big><em>data</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#ProtocolConsumer.data_received"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.ProtocolConsumer.data_received" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when some data is received.</p>
<p><strong>This method must be implemented by subclasses</strong> for both server and
client consumers.</p>
<p>The argument is a bytes object.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.protocols.ProtocolConsumer.start_request">
<tt class="descname">start_request</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#ProtocolConsumer.start_request"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.ProtocolConsumer.start_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Starts a new request.</p>
<p>Invoked by the <a class="reference internal" href="#pulsar.async.protocols.ProtocolConsumer.start" title="pulsar.async.protocols.ProtocolConsumer.start"><tt class="xref py py-meth docutils literal"><span class="pre">start()</span></tt></a> method to kick start the
request with remote server. For server <a class="reference internal" href="#pulsar.async.protocols.ProtocolConsumer" title="pulsar.async.protocols.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> this
method is not invoked at all.</p>
<p><strong>For clients this method should be implemented</strong> and it is critical
method where errors caused by stale socket connections can arise.
<strong>This method should not be called directly.</strong> Use <a class="reference internal" href="#pulsar.async.protocols.ProtocolConsumer.start" title="pulsar.async.protocols.ProtocolConsumer.start"><tt class="xref py py-meth docutils literal"><span class="pre">start()</span></tt></a>
instead. Typically one writes some data from the <a class="reference internal" href="#pulsar.async.protocols.ProtocolConsumer.request" title="pulsar.async.protocols.ProtocolConsumer.request"><tt class="xref py py-attr docutils literal"><span class="pre">request</span></tt></a>
into the transport. Something like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.protocols.ProtocolConsumer.start">
<tt class="descname">start</tt><big>(</big><em>request=None</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#ProtocolConsumer.start"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.ProtocolConsumer.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Starts processing the request for this protocol consumer.</p>
<p>There is no need to override this method,
implement <a class="reference internal" href="#pulsar.async.protocols.ProtocolConsumer.start_request" title="pulsar.async.protocols.ProtocolConsumer.start_request"><tt class="xref py py-meth docutils literal"><span class="pre">start_request()</span></tt></a> instead.
If either <a class="reference internal" href="#pulsar.async.protocols.ProtocolConsumer.connection" title="pulsar.async.protocols.ProtocolConsumer.connection"><tt class="xref py py-attr docutils literal"><span class="pre">connection</span></tt></a> or <a class="reference internal" href="#pulsar.async.protocols.ProtocolConsumer.transport" title="pulsar.async.protocols.ProtocolConsumer.transport"><tt class="xref py py-attr docutils literal"><span class="pre">transport</span></tt></a> are missing, a
<tt class="xref py py-class docutils literal"><span class="pre">RuntimeError</span></tt> occurs.</p>
<p>For server side consumer, this method simply fires the <tt class="docutils literal"><span class="pre">pre_request</span></tt>
event.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.protocols.ProtocolConsumer.connection_lost">
<tt class="descname">connection_lost</tt><big>(</big><em>exc</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#ProtocolConsumer.connection_lost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.ProtocolConsumer.connection_lost" title="Permalink to this definition">¶</a></dt>
<dd><p>Called by the <a class="reference internal" href="#pulsar.async.protocols.ProtocolConsumer.connection" title="pulsar.async.protocols.ProtocolConsumer.connection"><tt class="xref py py-attr docutils literal"><span class="pre">connection</span></tt></a> when the transport is closed.</p>
<p>By default it calls the <a class="reference internal" href="#pulsar.async.protocols.ProtocolConsumer.finished" title="pulsar.async.protocols.ProtocolConsumer.finished"><tt class="xref py py-meth docutils literal"><span class="pre">finished()</span></tt></a> method. It can be overwritten
to handle the potential exception <tt class="docutils literal"><span class="pre">exc</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.protocols.ProtocolConsumer.finished">
<tt class="descname">finished</tt><big>(</big><em>exc=None</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#ProtocolConsumer.finished"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.ProtocolConsumer.finished" title="Permalink to this definition">¶</a></dt>
<dd><p>Fire the <tt class="docutils literal"><span class="pre">post_request</span></tt> event if it wasn&#8217;t already fired.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="producers">
<h2>Producers<a class="headerlink" href="#producers" title="Permalink to this headline">¶</a></h2>
<p>Producers are factory of <a class="reference internal" href="#pulsar.async.protocols.Protocol" title="pulsar.async.protocols.Protocol"><tt class="xref py py-class docutils literal"><span class="pre">Protocol</span></tt></a> with end-points.
They are used by both servers and clients classes.</p>
<div class="section" id="producer">
<h3>Producer<a class="headerlink" href="#producer" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pulsar.async.protocols.Producer">
<em class="property">class </em><tt class="descclassname">pulsar.async.protocols.</tt><tt class="descname">Producer</tt><big>(</big><em>loop</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#Producer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.Producer" title="Permalink to this definition">¶</a></dt>
<dd><p>An Abstract <a class="reference internal" href="events.html#pulsar.async.events.EventHandler" title="pulsar.async.events.EventHandler"><tt class="xref py py-class docutils literal"><span class="pre">EventHandler</span></tt></a> class for all producers of
connections.</p>
<dl class="attribute">
<dt id="pulsar.async.protocols.Producer.protocol_factory">
<tt class="descname">protocol_factory</tt><em class="property"> = None</em><a class="headerlink" href="#pulsar.async.protocols.Producer.protocol_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>A callable producing protocols.</p>
<p>The signature of the protocol factory callable must be:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">protocol_factory</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">producer</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.async.protocols.Producer.sessions">
<tt class="descname">sessions</tt><a class="reference internal" href="../modules/pulsar/async/protocols.html#Producer.sessions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.Producer.sessions" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of protocols created by the <a class="reference internal" href="#pulsar.async.protocols.Producer" title="pulsar.async.protocols.Producer"><tt class="xref py py-class docutils literal"><span class="pre">Producer</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.async.protocols.Producer.requests_processed">
<tt class="descname">requests_processed</tt><a class="reference internal" href="../modules/pulsar/async/protocols.html#Producer.requests_processed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.Producer.requests_processed" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of requests processed.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.protocols.Producer.create_protocol">
<tt class="descname">create_protocol</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#Producer.create_protocol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.Producer.create_protocol" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new protocol via the <a class="reference internal" href="#pulsar.async.protocols.Producer.protocol_factory" title="pulsar.async.protocols.Producer.protocol_factory"><tt class="xref py py-meth docutils literal"><span class="pre">protocol_factory()</span></tt></a></p>
<p>This method increase the count of <a class="reference internal" href="#pulsar.async.protocols.Producer.sessions" title="pulsar.async.protocols.Producer.sessions"><tt class="xref py py-attr docutils literal"><span class="pre">sessions</span></tt></a> and build
the protocol passing <tt class="docutils literal"><span class="pre">self</span></tt> as the producer.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.protocols.Producer.build_consumer">
<tt class="descname">build_consumer</tt><big>(</big><em>consumer_factory</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#Producer.build_consumer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.Producer.build_consumer" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a consumer for a protocol.</p>
<p>This method can be used by protocols which handle several requests,
for example the <a class="reference internal" href="#pulsar.async.protocols.Connection" title="pulsar.async.protocols.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>consumer_factory</strong> &#8211; consumer factory to use.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="tcpserver">
<h3>TcpServer<a class="headerlink" href="#tcpserver" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pulsar.async.protocols.TcpServer">
<em class="property">class </em><tt class="descclassname">pulsar.async.protocols.</tt><tt class="descname">TcpServer</tt><big>(</big><em>protocol_factory</em>, <em>loop</em>, <em>address=None</em>, <em>name=None</em>, <em>sockets=None</em>, <em>max_connections=None</em>, <em>keep_alive=None</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#TcpServer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.TcpServer" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="#pulsar.async.protocols.Producer" title="pulsar.async.protocols.Producer"><tt class="xref py py-class docutils literal"><span class="pre">Producer</span></tt></a> of server <a class="reference internal" href="#pulsar.async.protocols.Connection" title="pulsar.async.protocols.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> for TCP servers.</p>
<dl class="attribute">
<dt id="pulsar.async.protocols.TcpServer._server">
<tt class="descname">_server</tt><a class="headerlink" href="#pulsar.async.protocols.TcpServer._server" title="Permalink to this definition">¶</a></dt>
<dd><p>A <tt class="xref py py-class docutils literal"><span class="pre">Server</span></tt> managed by this Tcp wrapper.</p>
<p>Available once the <a class="reference internal" href="#pulsar.async.protocols.TcpServer.start_serving" title="pulsar.async.protocols.TcpServer.start_serving"><tt class="xref py py-meth docutils literal"><span class="pre">start_serving()</span></tt></a> method has returned.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.async.protocols.TcpServer.address">
<tt class="descname">address</tt><a class="reference internal" href="../modules/pulsar/async/protocols.html#TcpServer.address"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.TcpServer.address" title="Permalink to this definition">¶</a></dt>
<dd><p>Socket address of this server.</p>
<p>It is obtained from the first socket <tt class="docutils literal"><span class="pre">getsockname</span></tt> method.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.protocols.TcpServer.start_serving">
<tt class="descname">start_serving</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#TcpServer.start_serving"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.TcpServer.start_serving" title="Permalink to this definition">¶</a></dt>
<dd><p>Start serving.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>backlog</strong> &#8211; Number of maximum connections</li>
<li><strong>sslcontext</strong> &#8211; optional SSLContext object.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a <a class="reference internal" href="async.html#pulsar.async.fallbacks.defer.Deferred" title="pulsar.async.fallbacks.defer.Deferred"><tt class="xref py py-class docutils literal"><span class="pre">Deferred</span></tt></a> called back when the server is
serving the socket.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.protocols.TcpServer.stop_serving">
<tt class="descname">stop_serving</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#TcpServer.stop_serving"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.TcpServer.stop_serving" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop serving the <tt class="xref py py-attr docutils literal"><span class="pre">Server.sockets</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.protocols.TcpServer.close">
<tt class="descname">close</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#TcpServer.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.TcpServer.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop serving the <tt class="xref py py-attr docutils literal"><span class="pre">Server.sockets</span></tt> and close all
concurrent connections.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.protocols.TcpServer.create_protocol">
<tt class="descname">create_protocol</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pulsar/async/protocols.html#TcpServer.create_protocol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.protocols.TcpServer.create_protocol" title="Permalink to this definition">¶</a></dt>
<dd><p>Override <a class="reference internal" href="#pulsar.async.protocols.Producer.create_protocol" title="pulsar.async.protocols.Producer.create_protocol"><tt class="xref py py-meth docutils literal"><span class="pre">Producer.create_protocol()</span></tt></a>.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-pulsar.async.clients"></span></div>
</div>
<div class="section" id="clients">
<span id="clients-api"></span><h2>Clients<a class="headerlink" href="#clients" title="Permalink to this headline">¶</a></h2>
<p>This section introduces classes implementing the transport/protocol paradigm
for clients with several connections to a remote <a class="reference internal" href="#pulsar.async.protocols.TcpServer" title="pulsar.async.protocols.TcpServer"><tt class="xref py py-class docutils literal"><span class="pre">TcpServer</span></tt></a>.</p>
<div class="section" id="abstract-client">
<h3>Abstract Client<a class="headerlink" href="#abstract-client" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pulsar.async.clients.AbstractClient">
<em class="property">class </em><tt class="descclassname">pulsar.async.clients.</tt><tt class="descname">AbstractClient</tt><big>(</big><em>loop</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/clients.html#AbstractClient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.clients.AbstractClient" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="#pulsar.async.protocols.Producer" title="pulsar.async.protocols.Producer"><tt class="xref py py-class docutils literal"><span class="pre">Producer</span></tt></a> for a client connections.</p>
<dl class="method">
<dt id="pulsar.async.clients.AbstractClient.connect">
<tt class="descname">connect</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pulsar/async/clients.html#AbstractClient.connect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.clients.AbstractClient.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method for creating a connection.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.clients.AbstractClient.close">
<tt class="descname">close</tt><big>(</big><em>async=True</em>, <em>timeout=5</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/clients.html#AbstractClient.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.clients.AbstractClient.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close all idle connections.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.clients.AbstractClient.abort">
<tt class="descname">abort</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pulsar/async/clients.html#AbstractClient.abort"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.clients.AbstractClient.abort" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#pulsar.async.clients.AbstractClient.close" title="pulsar.async.clients.AbstractClient.close"><tt class="xref py py-meth docutils literal"><span class="pre">close()</span></tt></a> all connections without waiting for active
connections to finish.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.clients.AbstractClient.create_connection">
<tt class="descname">create_connection</tt><big>(</big><em>address</em>, <em>protocol_factory=None</em>, <em>**kw</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/clients.html#AbstractClient.create_connection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.clients.AbstractClient.create_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method for creating a connection to an <tt class="docutils literal"><span class="pre">address</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.clients.AbstractClient.timeit">
<tt class="descname">timeit</tt><big>(</big><em>times</em>, <em>callable</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/clients.html#AbstractClient.timeit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.clients.AbstractClient.timeit" title="Permalink to this definition">¶</a></dt>
<dd><p>Send <tt class="docutils literal"><span class="pre">times</span></tt> requests asynchronously and evaluate the time
taken to obtain all responses.
Usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">multi</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">timeit</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">client</span><span class="o">.</span><span class="n">request</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
<span class="n">response</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">multi</span>
<span class="n">multi</span><span class="o">.</span><span class="n">total_time</span>
</pre></div>
</div>
<p>Where <tt class="docutils literal"><span class="pre">client.request</span></tt> is the callable method to invoke (this must
be specified by the client implementation).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a <a class="reference internal" href="async.html#pulsar.async.defer.MultiDeferred" title="pulsar.async.defer.MultiDeferred"><tt class="xref py py-class docutils literal"><span class="pre">MultiDeferred</span></tt></a> which results in the list of results
for the individual requests. Its <tt class="xref py py-attr docutils literal"><span class="pre">MultiDeferred.total_time</span></tt>
attribute indicates the number of seconds taken (once the deferred
has been called back).</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="pool">
<h3>Pool<a class="headerlink" href="#pool" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pulsar.async.clients.Pool">
<em class="property">class </em><tt class="descclassname">pulsar.async.clients.</tt><tt class="descname">Pool</tt><big>(</big><em>creator</em>, <em>pool_size=10</em>, <em>loop=None</em>, <em>timeout=None</em>, <em>**kw</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/clients.html#Pool"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.clients.Pool" title="Permalink to this definition">¶</a></dt>
<dd><p>An asynchronous pool of open connections.</p>
<p>Open connections are either <a class="reference internal" href="#pulsar.async.clients.Pool.in_use" title="pulsar.async.clients.Pool.in_use"><tt class="xref py py-attr docutils literal"><span class="pre">in_use</span></tt></a> or <a class="reference internal" href="#pulsar.async.clients.Pool.available" title="pulsar.async.clients.Pool.available"><tt class="xref py py-attr docutils literal"><span class="pre">available</span></tt></a>
to be used. Available connection are placed in an
asynchronous  <a class="reference internal" href="async.html#pulsar.async.queues.Queue" title="pulsar.async.queues.Queue"><tt class="xref py py-class docutils literal"><span class="pre">Queue</span></tt></a>.</p>
<p>This class is not thread safe.</p>
<dl class="attribute">
<dt id="pulsar.async.clients.Pool.pool_size">
<tt class="descname">pool_size</tt><a class="reference internal" href="../modules/pulsar/async/clients.html#Pool.pool_size"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.clients.Pool.pool_size" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum number of open connections allowed.</p>
<p>If more connections are requested, the request
is queued and a connection returned as soon as one becomes
available.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.async.clients.Pool.in_use">
<tt class="descname">in_use</tt><a class="reference internal" href="../modules/pulsar/async/clients.html#Pool.in_use"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.clients.Pool.in_use" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of connections in use.</p>
<p>These connections are not available until they are released back
to the pool.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.async.clients.Pool.available">
<tt class="descname">available</tt><a class="reference internal" href="../modules/pulsar/async/clients.html#Pool.available"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.clients.Pool.available" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of available connections in the pool.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.clients.Pool.connect">
<tt class="descname">connect</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pulsar/async/clients.html#Pool.connect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.clients.Pool.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a connection from the pool.</p>
<p>The connection is either a new one or retrieved from the
<a class="reference internal" href="#pulsar.async.clients.Pool.available" title="pulsar.async.clients.Pool.available"><tt class="xref py py-attr docutils literal"><span class="pre">available</span></tt></a> connections in the pool.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a <a class="reference internal" href="async.html#pulsar.async.fallbacks.defer.Deferred" title="pulsar.async.fallbacks.defer.Deferred"><tt class="xref py py-class docutils literal"><span class="pre">Deferred</span></tt></a> resulting in the connection.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.clients.Pool.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pulsar/async/clients.html#Pool.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.clients.Pool.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close all <a class="reference internal" href="#pulsar.async.clients.Pool.available" title="pulsar.async.clients.Pool.available"><tt class="xref py py-attr docutils literal"><span class="pre">available</span></tt></a> and <a class="reference internal" href="#pulsar.async.clients.Pool.in_use" title="pulsar.async.clients.Pool.in_use"><tt class="xref py py-attr docutils literal"><span class="pre">in_use</span></tt></a> connections.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="pool-connection">
<h3>Pool Connection<a class="headerlink" href="#pool-connection" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pulsar.async.clients.PoolConnection">
<em class="property">class </em><tt class="descclassname">pulsar.async.clients.</tt><tt class="descname">PoolConnection</tt><big>(</big><em>pool</em>, <em>connection</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/clients.html#PoolConnection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.clients.PoolConnection" title="Permalink to this definition">¶</a></dt>
<dd><p>A wrapper for a <tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt> in a connection <a class="reference internal" href="#pulsar.async.clients.Pool" title="pulsar.async.clients.Pool"><tt class="xref py py-class docutils literal"><span class="pre">Pool</span></tt></a>.</p>
<p>Objects are never initialised directly, instead they are <cite>checked-out</cite>
via the <a class="reference internal" href="#pulsar.async.clients.PoolConnection.checkout" title="pulsar.async.clients.PoolConnection.checkout"><tt class="xref py py-meth docutils literal"><span class="pre">checkout()</span></tt></a> class method from the <a class="reference internal" href="#pulsar.async.clients.Pool.connect" title="pulsar.async.clients.Pool.connect"><tt class="xref py py-meth docutils literal"><span class="pre">Pool.connect()</span></tt></a>
method.</p>
<dl class="attribute">
<dt id="pulsar.async.clients.PoolConnection.pool">
<tt class="descname">pool</tt><a class="headerlink" href="#pulsar.async.clients.PoolConnection.pool" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pulsar.async.clients.Pool" title="pulsar.async.clients.Pool"><tt class="xref py py-class docutils literal"><span class="pre">Pool</span></tt></a> which created this <a class="reference internal" href="#pulsar.async.clients.PoolConnection" title="pulsar.async.clients.PoolConnection"><tt class="xref py py-class docutils literal"><span class="pre">PoolConnection</span></tt></a></p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.async.clients.PoolConnection.connection">
<tt class="descname">connection</tt><a class="headerlink" href="#pulsar.async.clients.PoolConnection.connection" title="Permalink to this definition">¶</a></dt>
<dd><p>The underlying socket connection.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.clients.PoolConnection.close">
<tt class="descname">close</tt><big>(</big><em>discard=False</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/clients.html#PoolConnection.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.clients.PoolConnection.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close this pool connection by releasing the underlying
<a class="reference internal" href="#pulsar.async.clients.PoolConnection.connection" title="pulsar.async.clients.PoolConnection.connection"><tt class="xref py py-attr docutils literal"><span class="pre">connection</span></tt></a> back to the ;attr:<cite>pool</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.async.clients.PoolConnection.detach">
<tt class="descname">detach</tt><big>(</big><big>)</big><a class="reference internal" href="../modules/pulsar/async/clients.html#PoolConnection.detach"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.clients.PoolConnection.detach" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the underlying <a class="reference internal" href="#pulsar.async.clients.PoolConnection.connection" title="pulsar.async.clients.PoolConnection.connection"><tt class="xref py py-attr docutils literal"><span class="pre">connection</span></tt></a> from the connection
<a class="reference internal" href="#pulsar.async.clients.PoolConnection.pool" title="pulsar.async.clients.PoolConnection.pool"><tt class="xref py py-attr docutils literal"><span class="pre">pool</span></tt></a>.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pulsar.async.clients.PoolConnection.checkout">
<em class="property">classmethod </em><tt class="descname">checkout</tt><big>(</big><em>pool</em><big>)</big><a class="reference internal" href="../modules/pulsar/async/clients.html#PoolConnection.checkout"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pulsar.async.clients.PoolConnection.checkout" title="Permalink to this definition">¶</a></dt>
<dd><p>Checkout a new connection from <tt class="docutils literal"><span class="pre">pool</span></tt>.</p>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper"><p class="logo">
<a href="../index.html">
  <img class="logo" width="200" src="../static/pulsar.png" alt="pulsar" title="Pulsar"/>
</a>
</p>
<div class="g-plusone"></div>
<script type="text/javascript">
  window.___gcfg = {lang: 'en-GB'};
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
<br>
<a href="https://twitter.com/share" class="twitter-share-button" data-size="large">Tweet</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<br>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Protocols/Transports API</a><ul>
<li><a class="reference internal" href="#transports">Transports</a><ul>
<li><a class="reference internal" href="#sockettransport">SocketTransport</a></li>
<li><a class="reference internal" href="#socketstreamtransport">SocketStreamTransport</a></li>
<li><a class="reference internal" href="#socketstreamssltransport">SocketStreamSslTransport</a></li>
</ul>
</li>
<li><a class="reference internal" href="#protocols">Protocols</a><ul>
<li><a class="reference internal" href="#protocol">Protocol</a></li>
<li><a class="reference internal" href="#connection">Connection</a></li>
<li><a class="reference internal" href="#protocol-consumer">Protocol Consumer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#producers">Producers</a><ul>
<li><a class="reference internal" href="#producer">Producer</a></li>
<li><a class="reference internal" href="#tcpserver">TcpServer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#clients">Clients</a><ul>
<li><a class="reference internal" href="#abstract-client">Abstract Client</a></li>
<li><a class="reference internal" href="#pool">Pool</a></li>
<li><a class="reference internal" href="#pool-connection">Pool Connection</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="events.html"
                        title="previous chapter">Event API</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="application.html"
                        title="next chapter">Application API</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../sources/api/protocols.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>


<div class="footer">
     &copy; Copyright 2011-2013, Luca Sbardella.
   Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2b1.
 </div>


<script type="text/javascript">

  var _gaq = _gaq || [];
  
  _gaq.push(['_setAccount', 'UA-3900561-8']);
  
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</body>
</html>