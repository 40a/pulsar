
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Protocols API &mdash; pulsar v0.5b8 documentation</title>
    <link rel="stylesheet" href="../static/pulsar.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.5b8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <link rel="shortcut icon" href="../static/Game_of_life_pulsar.gif"/>
    <link rel="top" title="pulsar v0.5b8 documentation" href="../index.html" />
    <link rel="up" title="API" href="index.html" />
    <link rel="next" title="Applications API" href="application.html" />
    <link rel="prev" title="Actors API" href="actor.html" /> 
  </head>
  <body>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="application.html" title="Applications API"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="actor.html" title="Actors API"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">pulsar v0.5b8 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">API</a> &raquo;</li> 
      </ul>
    </div>
<div class="deck">
<div class="header">
    
        <p class="developmentversion">
        Documentation for pulsar's DEVELOPMENT version. Get the 
        <a href="http://packages.python.org/pulsar/">release docs here</a>.
        </p>
    
</div>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="module-pulsar"></span><div class="section" id="protocols-api">
<span id="protocol-api"></span><h1>Protocols API<a class="headerlink" href="#protocols-api" title="Permalink to this headline">¶</a></h1>
<p>This part of the <a class="reference internal" href="index.html#api"><em>pulsar API</em></a> is about classes responsible for
implementing the Protocol/Transport paradigm as well as <a class="reference internal" href="#pulsar.Server" title="pulsar.Server"><tt class="xref py py-class docutils literal"><span class="pre">Server</span></tt></a> and
<a class="reference internal" href="#pulsar.Client" title="pulsar.Client"><tt class="xref py py-class docutils literal"><span class="pre">Client</span></tt></a>.</p>
<div class="section" id="transport">
<h2>Transport<a class="headerlink" href="#transport" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pulsar.Transport">
<em class="property">class </em><tt class="descclassname">pulsar.</tt><tt class="descname">Transport</tt><a class="headerlink" href="#pulsar.Transport" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for pulsar transports. Design to conform with <a class="reference external" href="http://www.python.org/dev/peps/pep-3156/">pep-3156</a> as
close as possible until it is finalised. A transport is an abstraction on top
of a socket or something similar.
Form <a class="reference external" href="http://www.python.org/dev/peps/pep-3153/">pep-3153</a>:</p>
<p>Transports talk to two things: the other side of the
connection on one hand, and a <a class="reference internal" href="#pulsar.Transport.protocol" title="pulsar.Transport.protocol"><tt class="xref py py-attr docutils literal"><span class="pre">protocol</span></tt></a> on the other. It&#8217;s a bridge
between the specific underlying transfer mechanism and the protocol.
Its job can be described as allowing the protocol to just send and
receive bytes, taking care of all of the magic that needs to happen to those
bytes to be eventually sent across the wire.</p>
<p>The primary feature of a transport is sending bytes to a protocol and receiving
bytes from the underlying protocol. Writing to the transport is done using
the <a class="reference internal" href="#pulsar.Transport.write" title="pulsar.Transport.write"><tt class="xref py py-meth docutils literal"><span class="pre">write()</span></tt></a> and <a class="reference internal" href="#pulsar.Transport.writelines" title="pulsar.Transport.writelines"><tt class="xref py py-meth docutils literal"><span class="pre">writelines()</span></tt></a> methods. The latter method is a
performance optimisation, to allow software to take advantage of specific
capabilities in some transport mechanisms.</p>
<dl class="attribute">
<dt id="pulsar.Transport.eventloop">
<tt class="descname">eventloop</tt><a class="headerlink" href="#pulsar.Transport.eventloop" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="async.html#pulsar.EventLoop" title="pulsar.EventLoop"><tt class="xref py py-class docutils literal"><span class="pre">EventLoop</span></tt></a> for this <a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Transport.protocol">
<tt class="descname">protocol</tt><a class="headerlink" href="#pulsar.Transport.protocol" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pulsar.Protocol" title="pulsar.Protocol"><tt class="xref py py-class docutils literal"><span class="pre">Protocol</span></tt></a> for this <a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Transport.sock">
<tt class="descname">sock</tt><a class="headerlink" href="#pulsar.Transport.sock" title="Permalink to this definition">¶</a></dt>
<dd><p>the socket/pipe for this <a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Transport.connecting">
<tt class="descname">connecting</tt><a class="headerlink" href="#pulsar.Transport.connecting" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref docutils literal"><span class="pre">True</span></tt> if the transport is connecting with remote server.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Transport.writing">
<tt class="descname">writing</tt><a class="headerlink" href="#pulsar.Transport.writing" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref docutils literal"><span class="pre">True</span></tt> if the transport has data in its writing buffer.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Transport.closing">
<tt class="descname">closing</tt><a class="headerlink" href="#pulsar.Transport.closing" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref docutils literal"><span class="pre">True</span></tt> if the transport is about to close.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Transport.closed">
<tt class="descname">closed</tt><a class="headerlink" href="#pulsar.Transport.closed" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="xref docutils literal"><span class="pre">True</span></tt> if the transport is closed.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Transport.write">
<tt class="descname">write</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pulsar.Transport.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write some data bytes to the transport.
This does not block; it buffers the data and arranges for it
to be sent out asynchronously.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Transport.writelines">
<tt class="descname">writelines</tt><big>(</big><em>list_of_data</em><big>)</big><a class="headerlink" href="#pulsar.Transport.writelines" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a list (or any iterable) of data bytes to the transport.
If <em>list_of_data</em> is a <strong>generator</strong>, and during iteration an empty byte is
yielded, the function will postpone writing the remaining of the generator
at the next loop in the <a class="reference internal" href="#pulsar.Transport.eventloop" title="pulsar.Transport.eventloop"><tt class="xref py py-attr docutils literal"><span class="pre">eventloop</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Transport.pause">
<tt class="descname">pause</tt><big>(</big><big>)</big><a class="headerlink" href="#pulsar.Transport.pause" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a> can be paused and resumed. Invoking this
method will cause the transport to buffer data coming from protocols but not
sending it to the <a class="reference internal" href="#pulsar.Transport.protocol" title="pulsar.Transport.protocol"><tt class="xref py py-attr docutils literal"><span class="pre">protocol</span></tt></a>. In other words, no data will be passed to
the <a class="reference internal" href="#pulsar.Protocol.data_received" title="pulsar.Protocol.data_received"><tt class="xref py py-meth docutils literal"><span class="pre">Protocol.data_received()</span></tt></a> method until <a class="reference internal" href="#pulsar.Transport.resume" title="pulsar.Transport.resume"><tt class="xref py py-meth docutils literal"><span class="pre">resume()</span></tt></a> is called.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Transport.resume">
<tt class="descname">resume</tt><big>(</big><big>)</big><a class="headerlink" href="#pulsar.Transport.resume" title="Permalink to this definition">¶</a></dt>
<dd><p>Resume the receiving end. Data received will once again be
passed to the <a class="reference internal" href="#pulsar.Protocol.data_received" title="pulsar.Protocol.data_received"><tt class="xref py py-meth docutils literal"><span class="pre">Protocol.data_received()</span></tt></a> method.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Transport.close">
<tt class="descname">close</tt><big>(</big><em>async=True</em>, <em>exc=None</em><big>)</big><a class="headerlink" href="#pulsar.Transport.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Closes the transport.</p>
<p>Buffered data will be flushed asynchronously.  No more data
will be received.  After all buffered data is flushed, the
protocol&#8217;s connection_lost() method will (eventually) called
with None as its argument.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Transport.abort">
<tt class="descname">abort</tt><big>(</big><em>exc=None</em><big>)</big><a class="headerlink" href="#pulsar.Transport.abort" title="Permalink to this definition">¶</a></dt>
<dd><p>Closes the transport immediately.</p>
<p>Buffered data will be lost.  No more data will be received.
The protocol&#8217;s connection_lost() method will (eventually) be
called with None as its argument.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="protocol">
<h2>Protocol<a class="headerlink" href="#protocol" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pulsar.Protocol">
<em class="property">class </em><tt class="descclassname">pulsar.</tt><tt class="descname">Protocol</tt><a class="headerlink" href="#pulsar.Protocol" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract class implemented in <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a>
and <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a></p>
<dl class="method">
<dt id="pulsar.Protocol.connection_made">
<tt class="descname">connection_made</tt><big>(</big><em>transport</em><big>)</big><a class="headerlink" href="#pulsar.Protocol.connection_made" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates that the <a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a> is ready and connected
to the entity at the other end. The protocol should probably save the
transport reference as an instance variable (so it can call its write()
and other methods later), and may write an initial greeting or request
at this point.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Protocol.data_received">
<tt class="descname">data_received</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pulsar.Protocol.data_received" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a> has read some data from <em>other end</em>
and it invokes this method.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Protocol.eof_received">
<tt class="descname">eof_received</tt><big>(</big><big>)</big><a class="headerlink" href="#pulsar.Protocol.eof_received" title="Permalink to this definition">¶</a></dt>
<dd><p>This is called when the other end called write_eof() (or
something equivalent).</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Protocol.connection_lost">
<tt class="descname">connection_lost</tt><big>(</big><em>exc</em><big>)</big><a class="headerlink" href="#pulsar.Protocol.connection_lost" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a> has been closed or aborted, has detected
that the other end has closed the connection cleanly, or has encountered an
unexpected error. In the first three cases the argument is None;
for an unexpected error, the argument is the exception that caused
the transport to give up.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="connection">
<h2>Connection<a class="headerlink" href="#connection" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pulsar.Connection">
<em class="property">class </em><tt class="descclassname">pulsar.</tt><tt class="descname">Connection</tt><big>(</big><em>address</em>, <em>session</em>, <em>timeout</em>, <em>consumer_factory</em>, <em>producer</em><big>)</big><a class="headerlink" href="#pulsar.Connection" title="Permalink to this definition">¶</a></dt>
<dd><p>A client or server connection with an end-point. This is not
connected until <a class="reference internal" href="#pulsar.Protocol.connection_made" title="pulsar.Protocol.connection_made"><tt class="xref py py-meth docutils literal"><span class="pre">Protocol.connection_made()</span></tt></a> is called by the
<a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a>. This class is the bridge between the <a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a>
and the <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a>. It has a <a class="reference internal" href="#pulsar.Protocol" title="pulsar.Protocol"><tt class="xref py py-class docutils literal"><span class="pre">Protocol</span></tt></a>
interface and it routes data arriving from the <a class="reference internal" href="#pulsar.Connection.transport" title="pulsar.Connection.transport"><tt class="xref py py-attr docutils literal"><span class="pre">transport</span></tt></a> to
the <a class="reference internal" href="#pulsar.Connection.current_consumer" title="pulsar.Connection.current_consumer"><tt class="xref py py-attr docutils literal"><span class="pre">current_consumer</span></tt></a>, an instance of <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a>.</p>
<p>It has two <a class="reference internal" href="../tutorials/events.html#one-time-event"><em>one time events</em></a>:</p>
<ul class="simple">
<li><em>connection_made</em></li>
<li><em>connection_lost</em></li>
</ul>
<p>and three <a class="reference internal" href="../tutorials/events.html#many-times-event"><em>many times events</em></a>:</p>
<ul class="simple">
<li><em>pre_request</em></li>
<li><em>data_received</em></li>
<li><em>post_request</em></li>
</ul>
<dl class="attribute">
<dt id="pulsar.Connection.producer">
<tt class="descname">producer</tt><a class="headerlink" href="#pulsar.Connection.producer" title="Permalink to this definition">¶</a></dt>
<dd><p>The producer of this <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a>, It is either a <a class="reference internal" href="#pulsar.Server" title="pulsar.Server"><tt class="xref py py-class docutils literal"><span class="pre">Server</span></tt></a>
or a client <a class="reference internal" href="#pulsar.Client" title="pulsar.Client"><tt class="xref py py-class docutils literal"><span class="pre">Client</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Connection.transport">
<tt class="descname">transport</tt><a class="headerlink" href="#pulsar.Connection.transport" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a> of this protocol connection. Initialised once the
<a class="reference internal" href="#pulsar.Protocol.connection_made" title="pulsar.Protocol.connection_made"><tt class="xref py py-meth docutils literal"><span class="pre">Protocol.connection_made()</span></tt></a> is called.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Connection.consumer_factory">
<tt class="descname">consumer_factory</tt><a class="headerlink" href="#pulsar.Connection.consumer_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>A factory of <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> instances for this
<a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Connection.session">
<tt class="descname">session</tt><a class="headerlink" href="#pulsar.Connection.session" title="Permalink to this definition">¶</a></dt>
<dd><p>Connection session number. Created by the <a class="reference internal" href="#pulsar.Connection.producer" title="pulsar.Connection.producer"><tt class="xref py py-attr docutils literal"><span class="pre">producer</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Connection.processed">
<tt class="descname">processed</tt><a class="headerlink" href="#pulsar.Connection.processed" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of separate requests processed by this connection.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Connection.current_consumer">
<tt class="descname">current_consumer</tt><a class="headerlink" href="#pulsar.Connection.current_consumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> currently handling incoming data.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Connection.set_consumer">
<tt class="descname">set_consumer</tt><big>(</big><em>consumer</em><big>)</big><a class="headerlink" href="#pulsar.Connection.set_consumer" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a new <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> for this <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Connection.connection_lost">
<tt class="descname">connection_lost</tt><big>(</big><em>exc</em><big>)</big><a class="headerlink" href="#pulsar.Connection.connection_lost" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the <a class="reference internal" href="#pulsar.Protocol.connection_lost" title="pulsar.Protocol.connection_lost"><tt class="xref py py-meth docutils literal"><span class="pre">Protocol.connection_lost()</span></tt></a> method. It performs
these actions in the following order:</p>
<ul class="simple">
<li>Cancel the idle timeout if set.</li>
<li>Fire the <em>connection_lost</em> <a class="reference internal" href="../tutorials/events.html#one-time-event"><em>one time event</em></a> with <em>exc</em>
as event data.</li>
<li>Invokes the connection_lost method in the <a class="reference internal" href="#pulsar.Connection.current_consumer" title="pulsar.Connection.current_consumer"><tt class="xref py py-attr docutils literal"><span class="pre">current_consumer</span></tt></a> if
available.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="pulsar.Connection.upgrade">
<tt class="descname">upgrade</tt><big>(</big><em>consumer_factory</em><big>)</big><a class="headerlink" href="#pulsar.Connection.upgrade" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the <a class="reference internal" href="#pulsar.Connection.consumer_factory" title="pulsar.Connection.consumer_factory"><tt class="xref py py-attr docutils literal"><span class="pre">consumer_factory</span></tt></a> attribute with a new
<a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> factory. This function can be used when the protocol
specification changes during a response (an example is a WebSocket
response).</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Connection.finished">
<tt class="descname">finished</tt><big>(</big><em>consumer</em>, <em>result=None</em><big>)</big><a class="headerlink" href="#pulsar.Connection.finished" title="Permalink to this definition">¶</a></dt>
<dd><p>Call this method to finish with the the current <em>consumer</em>.
the <em>consumer</em> must be the same as the <a class="reference internal" href="#pulsar.Connection.current_consumer" title="pulsar.Connection.current_consumer"><tt class="xref py py-attr docutils literal"><span class="pre">current_consumer</span></tt></a> attribute.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="protocol-consumer">
<h2>Protocol Consumer<a class="headerlink" href="#protocol-consumer" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pulsar.ProtocolConsumer">
<em class="property">class </em><tt class="descclassname">pulsar.</tt><tt class="descname">ProtocolConsumer</tt><big>(</big><em>connection=None</em><big>)</big><a class="headerlink" href="#pulsar.ProtocolConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pulsar.Protocol" title="pulsar.Protocol"><tt class="xref py py-class docutils literal"><span class="pre">Protocol</span></tt></a> consumer is one most important
<a class="reference internal" href="index.html#pulsar-primitives"><em>pulsar primitive</em></a>. It is responsible for receiving
incoming data from a the <a class="reference internal" href="#pulsar.Protocol.data_received" title="pulsar.Protocol.data_received"><tt class="xref py py-meth docutils literal"><span class="pre">Protocol.data_received()</span></tt></a> method implemented
in <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a>. It is used to decode and producing responses, i.e.
writing back to the client or server via
the <a class="reference internal" href="#pulsar.ProtocolConsumer.transport" title="pulsar.ProtocolConsumer.transport"><tt class="xref py py-attr docutils literal"><span class="pre">transport</span></tt></a> attribute. The only method to implement should
be <a class="reference internal" href="#pulsar.Protocol.data_received" title="pulsar.Protocol.data_received"><tt class="xref py py-meth docutils literal"><span class="pre">Protocol.data_received()</span></tt></a>.</p>
<p>It has one <a class="reference internal" href="../tutorials/events.html#one-time-event"><em>one time events</em></a>:</p>
<ul class="simple">
<li><em>finish</em> fired when this <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> has finished consuming
data and a response/exception is available.</li>
</ul>
<p>and three <a class="reference internal" href="../tutorials/events.html#many-times-event"><em>many times events</em></a>:</p>
<ul class="simple">
<li><em>data_received</em> fired each time new data is consumed by
this <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a>.</li>
</ul>
<dl class="attribute">
<dt id="pulsar.ProtocolConsumer.connection">
<tt class="descname">connection</tt><a class="headerlink" href="#pulsar.ProtocolConsumer.connection" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> of this consumer</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.ProtocolConsumer.transport">
<tt class="descname">transport</tt><a class="headerlink" href="#pulsar.ProtocolConsumer.transport" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a> of this consumer</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.ProtocolConsumer.request">
<tt class="descname">request</tt><a class="headerlink" href="#pulsar.ProtocolConsumer.request" title="Permalink to this definition">¶</a></dt>
<dd><p>Optional <tt class="xref py py-class docutils literal"><span class="pre">Request</span></tt> instance (used for clients).</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.ProtocolConsumer.on_finished">
<tt class="descname">on_finished</tt><a class="headerlink" href="#pulsar.ProtocolConsumer.on_finished" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="async.html#pulsar.Deferred" title="pulsar.Deferred"><tt class="xref py py-class docutils literal"><span class="pre">Deferred</span></tt></a> called once the <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> has
finished consuming protocol. It is called by the
<a class="reference internal" href="#pulsar.ProtocolConsumer.connection" title="pulsar.ProtocolConsumer.connection"><tt class="xref py py-attr docutils literal"><span class="pre">connection</span></tt></a> before disposing of this consumer. It is
a proxy of <tt class="docutils literal"><span class="pre">self.event('finish')</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.ProtocolConsumer.start_request">
<tt class="descname">start_request</tt><big>(</big><big>)</big><a class="headerlink" href="#pulsar.ProtocolConsumer.start_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoked by the <a class="reference internal" href="#pulsar.ProtocolConsumer.new_request" title="pulsar.ProtocolConsumer.new_request"><tt class="xref py py-meth docutils literal"><span class="pre">new_request()</span></tt></a> method to kick start the
request with remote server/client. For server <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> this
method is usually not implemented and therefore is simply a pass-through.
If implemented this is critical method
where errors caused by stale socket connections can arise.
<strong>This method should not be called directly.</strong> Use <a class="reference internal" href="#pulsar.ProtocolConsumer.new_request" title="pulsar.ProtocolConsumer.new_request"><tt class="xref py py-meth docutils literal"><span class="pre">new_request()</span></tt></a>
instead.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.ProtocolConsumer.new_request">
<tt class="descname">new_request</tt><big>(</big><em>request=None</em><big>)</big><a class="headerlink" href="#pulsar.ProtocolConsumer.new_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Starts a new <em>request</em> for this protocol consumer if
<tt class="xref py py-attr docutils literal"><span class="pre">connected</span></tt> is <cite>True</cite>. There is no need to override this method,
implement <a class="reference internal" href="#pulsar.ProtocolConsumer.start_request" title="pulsar.ProtocolConsumer.start_request"><tt class="xref py py-meth docutils literal"><span class="pre">start_request()</span></tt></a> instead.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.ProtocolConsumer.reset_connection">
<tt class="descname">reset_connection</tt><big>(</big><big>)</big><a class="headerlink" href="#pulsar.ProtocolConsumer.reset_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Cleanly dispose of the current <a class="reference internal" href="#pulsar.ProtocolConsumer.connection" title="pulsar.ProtocolConsumer.connection"><tt class="xref py py-attr docutils literal"><span class="pre">connection</span></tt></a>. Used
by client consumers only.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.ProtocolConsumer.finished">
<tt class="descname">finished</tt><big>(</big><em>result=None</em><big>)</big><a class="headerlink" href="#pulsar.ProtocolConsumer.finished" title="Permalink to this definition">¶</a></dt>
<dd><p>Call this method when done with this <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a>.
By default it calls the <a class="reference internal" href="#pulsar.Connection.finished" title="pulsar.Connection.finished"><tt class="xref py py-meth docutils literal"><span class="pre">Connection.finished()</span></tt></a> method of the
<a class="reference internal" href="#pulsar.ProtocolConsumer.connection" title="pulsar.ProtocolConsumer.connection"><tt class="xref py py-attr docutils literal"><span class="pre">connection</span></tt></a> attribute.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="producer">
<h2>Producer<a class="headerlink" href="#producer" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pulsar.Producer">
<em class="property">class </em><tt class="descclassname">pulsar.</tt><tt class="descname">Producer</tt><big>(</big><em>max_connections=0</em>, <em>timeout=0</em>, <em>connection_factory=None</em><big>)</big><a class="headerlink" href="#pulsar.Producer" title="Permalink to this definition">¶</a></dt>
<dd><p>A Producer of <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> with remote servers or clients.
It is the base class for both <a class="reference internal" href="#pulsar.Server" title="pulsar.Server"><tt class="xref py py-class docutils literal"><span class="pre">Server</span></tt></a> and <a class="reference internal" href="#pulsar.ConnectionPool" title="pulsar.ConnectionPool"><tt class="xref py py-class docutils literal"><span class="pre">ConnectionPool</span></tt></a>.
The main method in this class is <a class="reference internal" href="#pulsar.Producer.new_connection" title="pulsar.Producer.new_connection"><tt class="xref py py-meth docutils literal"><span class="pre">new_connection()</span></tt></a> where a new
<a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> is created and added to the set of
<a class="reference internal" href="#pulsar.Producer.concurrent_connections" title="pulsar.Producer.concurrent_connections"><tt class="xref py py-attr docutils literal"><span class="pre">concurrent_connections</span></tt></a>.</p>
<dl class="attribute">
<dt id="pulsar.Producer.connection_factory">
<tt class="descname">connection_factory</tt><a class="headerlink" href="#pulsar.Producer.connection_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>A factory producing the <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> from a
remote client with this producer.
This attribute is used in the <a class="reference internal" href="#pulsar.Producer.new_connection" title="pulsar.Producer.new_connection"><tt class="xref py py-meth docutils literal"><span class="pre">new_connection()</span></tt></a> method.
There shouldn&#8217;t be any reason to change the default <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a>,
it is here just in case.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Producer.concurrent_connections">
<tt class="descname">concurrent_connections</tt><a class="headerlink" href="#pulsar.Producer.concurrent_connections" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of concurrent active connections</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Producer.received">
<tt class="descname">received</tt><a class="headerlink" href="#pulsar.Producer.received" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of received connections</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Producer.timeout">
<tt class="descname">timeout</tt><a class="headerlink" href="#pulsar.Producer.timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>number of seconds to keep alive an idle connection</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Producer.max_connections">
<tt class="descname">max_connections</tt><a class="headerlink" href="#pulsar.Producer.max_connections" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum number of connections allowed. A value of 0 (default)
means no limit.</p>
</dd></dl>

<dl class="attribute">
<dt>
<tt class="descname">connection_factory</tt></dt>
<dd><p>alias of <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Producer.new_connection">
<tt class="descname">new_connection</tt><big>(</big><em>address</em>, <em>consumer_factory</em>, <em>producer=None</em><big>)</big><a class="headerlink" href="#pulsar.Producer.new_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when a new <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> is created. The <em>producer</em>
is either a <a class="reference internal" href="#pulsar.Server" title="pulsar.Server"><tt class="xref py py-class docutils literal"><span class="pre">Server</span></tt></a> or a <a class="reference internal" href="#pulsar.Client" title="pulsar.Client"><tt class="xref py py-class docutils literal"><span class="pre">Client</span></tt></a>. If the number of
<a class="reference internal" href="#pulsar.Producer.concurrent_connections" title="pulsar.Producer.concurrent_connections"><tt class="xref py py-attr docutils literal"><span class="pre">concurrent_connections</span></tt></a> is greater or equal <a class="reference internal" href="#pulsar.Producer.max_connections" title="pulsar.Producer.max_connections"><tt class="xref py py-attr docutils literal"><span class="pre">max_connections</span></tt></a>
a <tt class="xref py py-class docutils literal"><span class="pre">RuntimeError</span></tt> is raised.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Producer.close_connections">
<tt class="descname">close_connections</tt><big>(</big><em>connection=None</em>, <em>async=True</em><big>)</big><a class="headerlink" href="#pulsar.Producer.close_connections" title="Permalink to this definition">¶</a></dt>
<dd><p>Close <em>connection</em> if specified, otherwise close all
active connections.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="clients">
<h2>Clients<a class="headerlink" href="#clients" title="Permalink to this headline">¶</a></h2>
<p>This section introduces two classes for transport/protocol clients with several
connections to a remote <a class="reference internal" href="#pulsar.Server" title="pulsar.Server"><tt class="xref py py-class docutils literal"><span class="pre">Server</span></tt></a>.</p>
<div class="section" id="client">
<h3>Client<a class="headerlink" href="#client" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pulsar.Client">
<em class="property">class </em><tt class="descclassname">pulsar.</tt><tt class="descname">Client</tt><big>(</big><em>max_connections=None</em>, <em>timeout=None</em>, <em>client_version=None</em>, <em>trust_env=True</em>, <em>consumer_factory=None</em>, <em>max_reconnect=None</em>, <em>force_sync=False</em>, <em>**params</em><big>)</big><a class="headerlink" href="#pulsar.Client" title="Permalink to this definition">¶</a></dt>
<dd><p>A client for a remote server which handles one or more
<a class="reference internal" href="#pulsar.ConnectionPool" title="pulsar.ConnectionPool"><tt class="xref py py-class docutils literal"><span class="pre">ConnectionPool</span></tt></a> of asynchronous connections.</p>
<dl class="attribute">
<dt id="pulsar.Client.force_sync">
<tt class="descname">force_sync</tt><a class="headerlink" href="#pulsar.Client.force_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>Force a synchronous client, that is a client which has it
own <a class="reference internal" href="async.html#pulsar.EventLoop" title="pulsar.EventLoop"><tt class="xref py py-class docutils literal"><span class="pre">EventLoop</span></tt></a> and blocks until a response is available.</p>
<p>Default: <cite>False</cite></p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Client.connection_pool">
<tt class="descname">connection_pool</tt><a class="headerlink" href="#pulsar.Client.connection_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory of <a class="reference internal" href="#pulsar.ConnectionPool" title="pulsar.ConnectionPool"><tt class="xref py py-class docutils literal"><span class="pre">ConnectionPool</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Client.connection_factory">
<tt class="descname">connection_factory</tt><a class="headerlink" href="#pulsar.Client.connection_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>A factory of <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Client.reconnecting_gap">
<tt class="descname">reconnecting_gap</tt><a class="headerlink" href="#pulsar.Client.reconnecting_gap" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconnecting gap in seconds.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Client.client_version">
<tt class="descname">client_version</tt><a class="headerlink" href="#pulsar.Client.client_version" title="Permalink to this definition">¶</a></dt>
<dd><p>An optional version for this client</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Client.timeout">
<tt class="descname">timeout</tt><a class="headerlink" href="#pulsar.Client.timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Optional timeout in seconds for idle connections.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Client.consumer_factory">
<tt class="descname">consumer_factory</tt><a class="headerlink" href="#pulsar.Client.consumer_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>A factory of <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> for sending and consuming data.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Client.max_connections">
<tt class="descname">max_connections</tt><a class="headerlink" href="#pulsar.Client.max_connections" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum number of concurrent connections.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Client.connection_pools">
<tt class="descname">connection_pools</tt><a class="headerlink" href="#pulsar.Client.connection_pools" title="Permalink to this definition">¶</a></dt>
<dd><p>Dictionar of <a class="reference internal" href="#pulsar.ConnectionPool" title="pulsar.ConnectionPool"><tt class="xref py py-class docutils literal"><span class="pre">ConnectionPool</span></tt></a>. If initialized at class level it
will remain as a class attribute, otherwise it will be an instance attribute.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Client.max_reconnect">
<tt class="descname">max_reconnect</tt><a class="headerlink" href="#pulsar.Client.max_reconnect" title="Permalink to this definition">¶</a></dt>
<dd><p>Can reconnect on socket error.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Client.setup">
<tt class="descname">setup</tt><big>(</big><em>**params</em><big>)</big><a class="headerlink" href="#pulsar.Client.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup the client. By default it does nothing.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Client.request">
<tt class="descname">request</tt><big>(</big><em>*args</em>, <em>**params</em><big>)</big><a class="headerlink" href="#pulsar.Client.request" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method for creating a request to send to the server.
<strong>Must be implemented by subclasses</strong>. The method should return a
<a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> via invoking the <a class="reference internal" href="#pulsar.Client.response" title="pulsar.Client.response"><tt class="xref py py-meth docutils literal"><span class="pre">response()</span></tt></a> method.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Client.response">
<tt class="descname">response</tt><big>(</big><em>request</em><big>)</big><a class="headerlink" href="#pulsar.Client.response" title="Permalink to this definition">¶</a></dt>
<dd><p>Once a <em>request</em> object has been constructed, the <a class="reference internal" href="#pulsar.Client.request" title="pulsar.Client.request"><tt class="xref py py-meth docutils literal"><span class="pre">request()</span></tt></a>
method can invoke this method to build the protocol consumer and
start the response.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><strong>request</strong> &#8211; A custom <tt class="xref py py-class docutils literal"><span class="pre">Request</span></tt> for the <a class="reference internal" href="#pulsar.Client" title="pulsar.Client"><tt class="xref py py-class docutils literal"><span class="pre">Client</span></tt></a>.</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body">An <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> obtained form
<a class="reference internal" href="#pulsar.Client.consumer_factory" title="pulsar.Client.consumer_factory"><tt class="xref py py-attr docutils literal"><span class="pre">consumer_factory</span></tt></a>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pulsar.Client.get_connection">
<tt class="descname">get_connection</tt><big>(</big><em>request</em><big>)</big><a class="headerlink" href="#pulsar.Client.get_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a suitable <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> for <em>request</em>.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Client.update_parameters">
<tt class="descname">update_parameters</tt><big>(</big><em>parameter_list</em>, <em>params</em><big>)</big><a class="headerlink" href="#pulsar.Client.update_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Update <em>param</em> with attributes of this <a class="reference internal" href="#pulsar.Client" title="pulsar.Client"><tt class="xref py py-class docutils literal"><span class="pre">Client</span></tt></a> defined
in <tt class="xref py py-attr docutils literal"><span class="pre">request_parameters</span></tt> tuple.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Client.can_reuse_connection">
<tt class="descname">can_reuse_connection</tt><big>(</big><em>connection</em>, <em>response</em><big>)</big><a class="headerlink" href="#pulsar.Client.can_reuse_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoked by the <a class="reference internal" href="#pulsar.ConnectionPool.release_connection" title="pulsar.ConnectionPool.release_connection"><tt class="xref py py-meth docutils literal"><span class="pre">ConnectionPool.release_connection()</span></tt></a>, it checks
whether the <em>connection</em> can be reused in the future or it must be disposed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>connection</strong> &#8211; the <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> to check.</li>
<li><strong>response</strong> &#8211; the <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> which last consumed the incoming
data from the connection (it can be <tt class="xref docutils literal"><span class="pre">None</span></tt>).</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><tt class="xref docutils literal"><span class="pre">True</span></tt> or <tt class="xref docutils literal"><span class="pre">False</span></tt>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pulsar.Client.upgrade">
<tt class="descname">upgrade</tt><big>(</big><em>connection</em>, <em>protocol_factory</em><big>)</big><a class="headerlink" href="#pulsar.Client.upgrade" title="Permalink to this definition">¶</a></dt>
<dd><p>Upgrade an existing connection with a new protocol factory.
Return the upgraded connection only if the <a class="reference internal" href="#pulsar.Connection.current_consumer" title="pulsar.Connection.current_consumer"><tt class="xref py py-attr docutils literal"><span class="pre">Connection.current_consumer</span></tt></a>
is available.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="client-connection-pool">
<h3>Client Connection Pool<a class="headerlink" href="#client-connection-pool" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pulsar.ConnectionPool">
<em class="property">class </em><tt class="descclassname">pulsar.</tt><tt class="descname">ConnectionPool</tt><big>(</big><em>request</em>, <em>**params</em><big>)</big><a class="headerlink" href="#pulsar.ConnectionPool" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="#pulsar.Producer" title="pulsar.Producer"><tt class="xref py py-class docutils literal"><span class="pre">Producer</span></tt></a> of of active connections for client
protocols. It maintains a live set of connections.</p>
<dl class="attribute">
<dt id="pulsar.ConnectionPool.address">
<tt class="descname">address</tt><a class="headerlink" href="#pulsar.ConnectionPool.address" title="Permalink to this definition">¶</a></dt>
<dd><p>Address to connect to</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.ConnectionPool.release_connection">
<tt class="descname">release_connection</tt><big>(</big><em>connection</em>, <em>response=None</em><big>)</big><a class="headerlink" href="#pulsar.ConnectionPool.release_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Releases the <em>connection</em> back to the pool. This function remove
the <em>connection</em> from the set of concurrent connections and add it to the set
of available connections.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>connection</strong> &#8211; The connection to release</li>
<li><strong>response</strong> &#8211; Optional <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> which consumed the
connection.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pulsar.ConnectionPool.get_or_create_connection">
<tt class="descname">get_or_create_connection</tt><big>(</big><em>client</em><big>)</big><a class="headerlink" href="#pulsar.ConnectionPool.get_or_create_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Get or create a new connection for <em>client</em></p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="server">
<h2>Server<a class="headerlink" href="#server" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pulsar.Server">
<em class="property">class </em><tt class="descclassname">pulsar.</tt><tt class="descname">Server</tt><big>(</big><em>consumer_factory=None</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pulsar.Server" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="#pulsar.Producer" title="pulsar.Producer"><tt class="xref py py-class docutils literal"><span class="pre">Producer</span></tt></a> for all server&#8217;s listening for connections.
It is a producer of <a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a> for server protocols.</p>
<dl class="attribute">
<dt>
<tt class="descname">transport:</tt></dt>
<dd><p>The <a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a> listening for client connections.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Server.consumer_factory">
<tt class="descname">consumer_factory</tt><a class="headerlink" href="#pulsar.Server.consumer_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>Callable or a <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> class for producing
<a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> which handle the receiving, decoding and
sending of data.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Server.event_loop">
<tt class="descname">event_loop</tt><a class="headerlink" href="#pulsar.Server.event_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="async.html#pulsar.EventLoop" title="pulsar.EventLoop"><tt class="xref py py-class docutils literal"><span class="pre">EventLoop</span></tt></a> running the server.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Server.address">
<tt class="descname">address</tt><a class="headerlink" href="#pulsar.Server.address" title="Permalink to this definition">¶</a></dt>
<dd><p>Server address, where clients send requests to.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Server.timeout">
<tt class="descname">timeout</tt><a class="headerlink" href="#pulsar.Server.timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>A timeout in seconds for idle connections</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Server.data_received">
<tt class="descname">data_received</tt><big>(</big><em>sock</em>, <em>address</em><big>)</big><a class="headerlink" href="#pulsar.Server.data_received" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new server <a class="reference internal" href="#pulsar.Protocol" title="pulsar.Protocol"><tt class="xref py py-class docutils literal"><span class="pre">Protocol</span></tt></a> ready to serve its client.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pulsar.Server.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>eventloop=None</em>, <em>sock=None</em>, <em>address=None</em>, <em>backlog=1024</em>, <em>name=None</em>, <em>close_event_loop=None</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pulsar.Server.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new server!</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper"><p class="logo">
<a href="../index.html">
  <img class="logo" width="200" src="../static/pulsar.png" alt="pulsar" title="Pulsar"/>
</a>
</p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Protocols API</a><ul>
<li><a class="reference internal" href="#transport">Transport</a></li>
<li><a class="reference internal" href="#protocol">Protocol</a></li>
<li><a class="reference internal" href="#connection">Connection</a></li>
<li><a class="reference internal" href="#protocol-consumer">Protocol Consumer</a></li>
<li><a class="reference internal" href="#producer">Producer</a></li>
<li><a class="reference internal" href="#clients">Clients</a><ul>
<li><a class="reference internal" href="#client">Client</a></li>
<li><a class="reference internal" href="#client-connection-pool">Client Connection Pool</a></li>
</ul>
</li>
<li><a class="reference internal" href="#server">Server</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="actor.html"
                        title="previous chapter">Actors API</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="application.html"
                        title="next chapter">Applications API</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../sources/api/protocols.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>

    <div class="footer">
        &copy; Copyright 2011, Luca Sbardella.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
<script type="text/javascript">

  var _gaq = _gaq || [];
  
  _gaq.push(['_setAccount', 'UA-3900561-8']);
  
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

  </body>
</html>