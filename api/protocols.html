<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Protocols API &mdash; pulsar 0.5.2-beta.2 documentation</title>
    
    <link rel="stylesheet" href="../static/pulsar.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.5.2-beta.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <link rel="shortcut icon" href="../static/Game_of_life_pulsar.gif"/>
    <link rel="top" title="pulsar 0.5.2-beta.2 documentation" href="../index.html" />
    <link rel="up" title="API" href="index.html" />
    <link rel="next" title="Applications API" href="application.html" />
    <link rel="prev" title="Actors API" href="actor.html" /> 
  </head>
  <body>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="application.html" title="Applications API"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="actor.html" title="Actors API"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">pulsar 0.5.2-beta.2 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">API</a> &raquo;</li> 
      </ul>
    </div>
<div class="deck">
<div class="header">
    
        <p class="developmentversion">
        Documentation for pulsar's DEVELOPMENT version. Get the 
        <a href="http://pythonhosted.org/pulsar/api/protocols.html">release docs here</a>.
        </p>
    
</div>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="module-pulsar"></span><div class="section" id="protocols-api">
<span id="protocol-api"></span><h1>Protocols API<a class="headerlink" href="#protocols-api" title="Permalink to this headline">¶</a></h1>
<p>This part of the <a class="reference internal" href="index.html#api"><em>pulsar API</em></a> is about classes responsible for
implementing the Protocol/Transport paradigm as well as <a class="reference internal" href="#pulsar.Server" title="pulsar.Server"><tt class="xref py py-class docutils literal"><span class="pre">Server</span></tt></a> and
<a class="reference internal" href="#pulsar.Client" title="pulsar.Client"><tt class="xref py py-class docutils literal"><span class="pre">Client</span></tt></a> base classes. <a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a>
and <a class="reference internal" href="#pulsar.Protocol" title="pulsar.Protocol"><tt class="xref py py-class docutils literal"><span class="pre">Protocol</span></tt></a> are designed to
comply with <a class="reference external" href="http://www.python.org/dev/peps/pep-3156/">pep-3156</a> specification</p>
<div class="section" id="transport">
<h2>Transport<a class="headerlink" href="#transport" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pulsar.Transport">
<em class="property">class </em><tt class="descclassname">pulsar.</tt><tt class="descname">Transport</tt><a class="headerlink" href="#pulsar.Transport" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for pulsar transports. Design to conform with <a class="reference external" href="http://www.python.org/dev/peps/pep-3156/">pep-3156</a> as
close as possible until it is finalised. A transport is an abstraction on top
of a socket or something similar.
Form <a class="reference external" href="http://www.python.org/dev/peps/pep-3153/">pep-3153</a>:</p>
<p>Transports talk to two things: the other side of the
connection on one hand, and a <a class="reference internal" href="#pulsar.Transport.protocol" title="pulsar.Transport.protocol"><tt class="xref py py-attr docutils literal"><span class="pre">protocol</span></tt></a> on the other. It&#8217;s a bridge
between the specific underlying transfer mechanism and the protocol.
Its job can be described as allowing the protocol to just send and
receive bytes, taking care of all of the magic that needs to happen to those
bytes to be eventually sent across the wire.</p>
<p>The primary feature of a transport is sending bytes to a protocol and receiving
bytes from the underlying protocol. Writing to the transport is done using
the <a class="reference internal" href="#pulsar.Transport.write" title="pulsar.Transport.write"><tt class="xref py py-meth docutils literal"><span class="pre">write()</span></tt></a> and <a class="reference internal" href="#pulsar.Transport.writelines" title="pulsar.Transport.writelines"><tt class="xref py py-meth docutils literal"><span class="pre">writelines()</span></tt></a> methods. The latter method is a
performance optimisation, to allow software to take advantage of specific
capabilities in some transport mechanisms.</p>
<dl class="attribute">
<dt id="pulsar.Transport.event_loop">
<tt class="descname">event_loop</tt><a class="headerlink" href="#pulsar.Transport.event_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="async.html#pulsar.EventLoop" title="pulsar.EventLoop"><tt class="xref py py-class docutils literal"><span class="pre">EventLoop</span></tt></a> for this <a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Transport.protocol">
<tt class="descname">protocol</tt><a class="headerlink" href="#pulsar.Transport.protocol" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pulsar.Protocol" title="pulsar.Protocol"><tt class="xref py py-class docutils literal"><span class="pre">Protocol</span></tt></a> for this <a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Transport.sock">
<tt class="descname">sock</tt><a class="headerlink" href="#pulsar.Transport.sock" title="Permalink to this definition">¶</a></dt>
<dd><p>the socket/pipe for this <a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Transport.connecting">
<tt class="descname">connecting</tt><a class="headerlink" href="#pulsar.Transport.connecting" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">True</span></tt> if the transport is connecting with an end-point.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Transport.writing">
<tt class="descname">writing</tt><a class="headerlink" href="#pulsar.Transport.writing" title="Permalink to this definition">¶</a></dt>
<dd><p>The transport has data in the write buffer and it is not <a class="reference internal" href="#pulsar.Transport.closed" title="pulsar.Transport.closed"><tt class="xref py py-attr docutils literal"><span class="pre">closed</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Transport.closing">
<tt class="descname">closing</tt><a class="headerlink" href="#pulsar.Transport.closing" title="Permalink to this definition">¶</a></dt>
<dd><p>The transport is about to close. In this state the transport is not
listening for <tt class="docutils literal"><span class="pre">read</span></tt> events but it may still be writing, unless it
is <a class="reference internal" href="#pulsar.Transport.closed" title="pulsar.Transport.closed"><tt class="xref py py-attr docutils literal"><span class="pre">closed</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Transport.closed">
<tt class="descname">closed</tt><a class="headerlink" href="#pulsar.Transport.closed" title="Permalink to this definition">¶</a></dt>
<dd><p>The transport is closed. No read/write operation avaibale.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Transport.write">
<tt class="descname">write</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pulsar.Transport.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write some data bytes to the transport.
This does not block; it buffers the data and arranges for it
to be sent out asynchronously.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Transport.writelines">
<tt class="descname">writelines</tt><big>(</big><em>list_of_data</em><big>)</big><a class="headerlink" href="#pulsar.Transport.writelines" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a list (or any iterable) of data bytes to the transport.
If <em>list_of_data</em> is a <strong>generator</strong>, and during iteration an empty byte is
yielded, the function will postpone writing the remaining of the generator
at the next loop in the <tt class="xref py py-attr docutils literal"><span class="pre">eventloop</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Transport.pause">
<tt class="descname">pause</tt><big>(</big><big>)</big><a class="headerlink" href="#pulsar.Transport.pause" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a> can be paused and resumed. Invoking this
method will cause the transport to buffer data coming from protocols but not
sending it to the <a class="reference internal" href="#pulsar.Transport.protocol" title="pulsar.Transport.protocol"><tt class="xref py py-attr docutils literal"><span class="pre">protocol</span></tt></a>. In other words, no data will be passed to
the <a class="reference internal" href="#pulsar.Protocol.data_received" title="pulsar.Protocol.data_received"><tt class="xref py py-meth docutils literal"><span class="pre">Protocol.data_received()</span></tt></a> method until <a class="reference internal" href="#pulsar.Transport.resume" title="pulsar.Transport.resume"><tt class="xref py py-meth docutils literal"><span class="pre">resume()</span></tt></a> is called.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Transport.resume">
<tt class="descname">resume</tt><big>(</big><big>)</big><a class="headerlink" href="#pulsar.Transport.resume" title="Permalink to this definition">¶</a></dt>
<dd><p>Resume the receiving end. Data received will once again be
passed to the <a class="reference internal" href="#pulsar.Protocol.data_received" title="pulsar.Protocol.data_received"><tt class="xref py py-meth docutils literal"><span class="pre">Protocol.data_received()</span></tt></a> method.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Transport.close">
<tt class="descname">close</tt><big>(</big><em>async=True</em>, <em>exc=None</em><big>)</big><a class="headerlink" href="#pulsar.Transport.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Closes the transport.</p>
<p>Buffered data will be flushed asynchronously.  No more data
will be received.  After all buffered data is flushed, the
protocol&#8217;s connection_lost() method will (eventually) called
with None as its argument.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Transport.abort">
<tt class="descname">abort</tt><big>(</big><em>exc=None</em><big>)</big><a class="headerlink" href="#pulsar.Transport.abort" title="Permalink to this definition">¶</a></dt>
<dd><p>Closes the transport immediately.</p>
<p>Buffered data will be lost.  No more data will be received.
The protocol&#8217;s connection_lost() method will (eventually) be
called with None as its argument.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="protocol">
<h2>Protocol<a class="headerlink" href="#protocol" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pulsar.Protocol">
<em class="property">class </em><tt class="descclassname">pulsar.</tt><tt class="descname">Protocol</tt><a class="headerlink" href="#pulsar.Protocol" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract class implemented in <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a>
and <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a>. It derives from <a class="reference internal" href="async.html#pulsar.EventHandler" title="pulsar.EventHandler"><tt class="xref py py-class docutils literal"><span class="pre">EventHandler</span></tt></a>
and therefore several events can be attached to subclasses.</p>
<dl class="method">
<dt id="pulsar.Protocol.connection_made">
<tt class="descname">connection_made</tt><big>(</big><em>transport</em><big>)</big><a class="headerlink" href="#pulsar.Protocol.connection_made" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates that the <a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a> is ready and connected
to the entity at the other end. The protocol should probably save the
transport reference as an instance variable (so it can call its write()
and other methods later), and may write an initial greeting or request
at this point.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Protocol.data_received">
<tt class="descname">data_received</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#pulsar.Protocol.data_received" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a> has read some data from <em>other end</em>
and it invokes this method.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Protocol.eof_received">
<tt class="descname">eof_received</tt><big>(</big><big>)</big><a class="headerlink" href="#pulsar.Protocol.eof_received" title="Permalink to this definition">¶</a></dt>
<dd><p>This is called when the other end called write_eof() (or
something equivalent).</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Protocol.connection_lost">
<tt class="descname">connection_lost</tt><big>(</big><em>exc</em><big>)</big><a class="headerlink" href="#pulsar.Protocol.connection_lost" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a> has been closed or aborted, has detected
that the other end has closed the connection cleanly, or has encountered an
unexpected error. In the first three cases the argument is None;
for an unexpected error, the argument is the exception that caused
the transport to give up.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="connection">
<h2>Connection<a class="headerlink" href="#connection" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pulsar.Connection">
<em class="property">class </em><tt class="descclassname">pulsar.</tt><tt class="descname">Connection</tt><big>(</big><em>address</em>, <em>session</em>, <em>timeout</em>, <em>consumer_factory</em>, <em>producer</em><big>)</big><a class="headerlink" href="#pulsar.Connection" title="Permalink to this definition">¶</a></dt>
<dd><p>A client or server connection with an end-point. This is not
connected until <a class="reference internal" href="#pulsar.Protocol.connection_made" title="pulsar.Protocol.connection_made"><tt class="xref py py-meth docutils literal"><span class="pre">Protocol.connection_made()</span></tt></a> is called by the
<a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a>. This class is the bridge between the <a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a>
and the <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a>. It has a <a class="reference internal" href="#pulsar.Protocol" title="pulsar.Protocol"><tt class="xref py py-class docutils literal"><span class="pre">Protocol</span></tt></a>
interface and it routes data arriving from the <a class="reference internal" href="#pulsar.Connection.transport" title="pulsar.Connection.transport"><tt class="xref py py-attr docutils literal"><span class="pre">transport</span></tt></a> to
the <a class="reference internal" href="#pulsar.Connection.current_consumer" title="pulsar.Connection.current_consumer"><tt class="xref py py-attr docutils literal"><span class="pre">current_consumer</span></tt></a>, an instance of <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a>.</p>
<p>It has two <a class="reference internal" href="../tutorials/events.html#one-time-event"><em>one time events</em></a>:</p>
<ul class="simple">
<li><em>connection_made</em></li>
<li><em>connection_lost</em></li>
</ul>
<p>and three <a class="reference internal" href="../tutorials/events.html#many-times-event"><em>many times events</em></a>:</p>
<ul class="simple">
<li><em>pre_request</em></li>
<li><em>data_received</em></li>
<li><em>post_request</em></li>
</ul>
<dl class="attribute">
<dt id="pulsar.Connection.producer">
<tt class="descname">producer</tt><a class="headerlink" href="#pulsar.Connection.producer" title="Permalink to this definition">¶</a></dt>
<dd><p>The producer of this <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a>, It is either a <a class="reference internal" href="#pulsar.Server" title="pulsar.Server"><tt class="xref py py-class docutils literal"><span class="pre">Server</span></tt></a>
or a client <a class="reference internal" href="#pulsar.Client" title="pulsar.Client"><tt class="xref py py-class docutils literal"><span class="pre">Client</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Connection.transport">
<tt class="descname">transport</tt><a class="headerlink" href="#pulsar.Connection.transport" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a> of this protocol connection. Initialised once the
<a class="reference internal" href="#pulsar.Protocol.connection_made" title="pulsar.Protocol.connection_made"><tt class="xref py py-meth docutils literal"><span class="pre">Protocol.connection_made()</span></tt></a> is called.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Connection.consumer_factory">
<tt class="descname">consumer_factory</tt><a class="headerlink" href="#pulsar.Connection.consumer_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>A factory of <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> instances for this
<a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Connection.session">
<tt class="descname">session</tt><a class="headerlink" href="#pulsar.Connection.session" title="Permalink to this definition">¶</a></dt>
<dd><p>Connection session number. Created by the <a class="reference internal" href="#pulsar.Connection.producer" title="pulsar.Connection.producer"><tt class="xref py py-attr docutils literal"><span class="pre">producer</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Connection.processed">
<tt class="descname">processed</tt><a class="headerlink" href="#pulsar.Connection.processed" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of separate <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> processed by this connection.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Connection.current_consumer">
<tt class="descname">current_consumer</tt><a class="headerlink" href="#pulsar.Connection.current_consumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> currently handling incoming data.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Connection.set_consumer">
<tt class="descname">set_consumer</tt><big>(</big><em>consumer</em><big>)</big><a class="headerlink" href="#pulsar.Connection.set_consumer" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a new <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> for this <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a>.
If the <a class="reference internal" href="#pulsar.Connection.current_consumer" title="pulsar.Connection.current_consumer"><tt class="xref py py-attr docutils literal"><span class="pre">current_consumer</span></tt></a> is not <tt class="docutils literal"><span class="pre">None</span></tt> an exception occurs</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Connection.connection_lost">
<tt class="descname">connection_lost</tt><big>(</big><em>exc</em><big>)</big><a class="headerlink" href="#pulsar.Connection.connection_lost" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the <a class="reference internal" href="#pulsar.Protocol.connection_lost" title="pulsar.Protocol.connection_lost"><tt class="xref py py-meth docutils literal"><span class="pre">Protocol.connection_lost()</span></tt></a> method. It performs
these actions in the following order:</p>
<ul class="simple">
<li>Cancel the idle timeout if set.</li>
<li>Fire the <em>connection_lost</em> <a class="reference internal" href="../tutorials/events.html#one-time-event"><em>one time event</em></a> with <em>exc</em>
as event data.</li>
<li>Invokes the connection_lost method in the <a class="reference internal" href="#pulsar.Connection.current_consumer" title="pulsar.Connection.current_consumer"><tt class="xref py py-attr docutils literal"><span class="pre">current_consumer</span></tt></a> if
available.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="pulsar.Connection.upgrade">
<tt class="descname">upgrade</tt><big>(</big><em>consumer_factory</em><big>)</big><a class="headerlink" href="#pulsar.Connection.upgrade" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the <a class="reference internal" href="#pulsar.Connection.consumer_factory" title="pulsar.Connection.consumer_factory"><tt class="xref py py-attr docutils literal"><span class="pre">consumer_factory</span></tt></a> attribute with a new
<a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> factory. This function can be used when the protocol
specification changes during a response (an example is a WebSocket
response).</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Connection.finished">
<tt class="descname">finished</tt><big>(</big><em>consumer</em>, <em>result=&lt;object object at 0x10b9e0170&gt;</em><big>)</big><a class="headerlink" href="#pulsar.Connection.finished" title="Permalink to this definition">¶</a></dt>
<dd><p>Call this method to finish with the the current <em>consumer</em>.
the <em>consumer</em> must be the same as the <a class="reference internal" href="#pulsar.Connection.current_consumer" title="pulsar.Connection.current_consumer"><tt class="xref py py-attr docutils literal"><span class="pre">current_consumer</span></tt></a> attribute.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="protocol-consumer">
<h2>Protocol Consumer<a class="headerlink" href="#protocol-consumer" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pulsar.ProtocolConsumer">
<em class="property">class </em><tt class="descclassname">pulsar.</tt><tt class="descname">ProtocolConsumer</tt><big>(</big><em>connection=None</em><big>)</big><a class="headerlink" href="#pulsar.ProtocolConsumer" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pulsar.Protocol" title="pulsar.Protocol"><tt class="xref py py-class docutils literal"><span class="pre">Protocol</span></tt></a> consumer is one most important
<a class="reference internal" href="index.html#pulsar-primitives"><em>pulsar primitive</em></a>. It is responsible for receiving
incoming data from a the <a class="reference internal" href="#pulsar.Protocol.data_received" title="pulsar.Protocol.data_received"><tt class="xref py py-meth docutils literal"><span class="pre">Protocol.data_received()</span></tt></a> method implemented
in <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a>. It is used to decode and producing responses, i.e.
writing back to the client or server via
the <a class="reference internal" href="#pulsar.ProtocolConsumer.transport" title="pulsar.ProtocolConsumer.transport"><tt class="xref py py-attr docutils literal"><span class="pre">transport</span></tt></a> attribute. The only method to implement should
be <a class="reference internal" href="#pulsar.Protocol.data_received" title="pulsar.Protocol.data_received"><tt class="xref py py-meth docutils literal"><span class="pre">Protocol.data_received()</span></tt></a>.</p>
<p>It has one <a class="reference internal" href="../tutorials/events.html#one-time-event"><em>one time events</em></a>:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">finish</span></tt> fired when this <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> has finished consuming
data and a response/exception is available. The <a class="reference internal" href="#pulsar.ProtocolConsumer.on_finished" title="pulsar.ProtocolConsumer.on_finished"><tt class="xref py py-attr docutils literal"><span class="pre">on_finished</span></tt></a>
is the <a class="reference internal" href="async.html#pulsar.Deferred" title="pulsar.Deferred"><tt class="xref py py-class docutils literal"><span class="pre">Deferred</span></tt></a> called back when this event occurs.</li>
</ul>
<p>and one <a class="reference internal" href="../tutorials/events.html#many-times-event"><em>many times events</em></a>:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">data_received</span></tt> fired each time new data is received by this
<a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> but not yet processed.</li>
<li><tt class="docutils literal"><span class="pre">data_processed</span></tt> fired each time new data is consumed by
this <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a>.</li>
</ul>
<dl class="attribute">
<dt id="pulsar.ProtocolConsumer.connection">
<tt class="descname">connection</tt><a class="headerlink" href="#pulsar.ProtocolConsumer.connection" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> of this consumer</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.ProtocolConsumer.current_request">
<tt class="descname">current_request</tt><a class="headerlink" href="#pulsar.ProtocolConsumer.current_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Current request instance (used for clients only).</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.ProtocolConsumer.connecting">
<tt class="descname">connecting</tt><a class="headerlink" href="#pulsar.ProtocolConsumer.connecting" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">True</span></tt> if connecting to endpoint (for servers this is always false).</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.ProtocolConsumer.connected">
<tt class="descname">connected</tt><a class="headerlink" href="#pulsar.ProtocolConsumer.connected" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">True</span></tt> if an end-point connection is available.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.ProtocolConsumer.producer">
<tt class="descname">producer</tt><a class="headerlink" href="#pulsar.ProtocolConsumer.producer" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pulsar.Producer" title="pulsar.Producer"><tt class="xref py py-class docutils literal"><span class="pre">Producer</span></tt></a> of this consumer.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.ProtocolConsumer.on_finished">
<tt class="descname">on_finished</tt><a class="headerlink" href="#pulsar.ProtocolConsumer.on_finished" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="async.html#pulsar.Deferred" title="pulsar.Deferred"><tt class="xref py py-class docutils literal"><span class="pre">Deferred</span></tt></a> called once the <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> has
finished consuming protocol. It is called by the
<a class="reference internal" href="#pulsar.ProtocolConsumer.connection" title="pulsar.ProtocolConsumer.connection"><tt class="xref py py-attr docutils literal"><span class="pre">connection</span></tt></a> before disposing of this consumer. It is
a proxy of <tt class="docutils literal"><span class="pre">self.event('finish')</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.ProtocolConsumer.transport">
<tt class="descname">transport</tt><a class="headerlink" href="#pulsar.ProtocolConsumer.transport" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a> of this consumer</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.ProtocolConsumer.closed">
<tt class="descname">closed</tt><a class="headerlink" href="#pulsar.ProtocolConsumer.closed" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pulsar.ProtocolConsumer.transport" title="pulsar.ProtocolConsumer.transport"><tt class="xref py py-attr docutils literal"><span class="pre">transport</span></tt></a> is closing or it is already closed.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.ProtocolConsumer.request_processed">
<tt class="descname">request_processed</tt><a class="headerlink" href="#pulsar.ProtocolConsumer.request_processed" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of requests processed by this consumer.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.ProtocolConsumer.start_request">
<tt class="descname">start_request</tt><big>(</big><big>)</big><a class="headerlink" href="#pulsar.ProtocolConsumer.start_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoked by the <a class="reference internal" href="#pulsar.ProtocolConsumer.new_request" title="pulsar.ProtocolConsumer.new_request"><tt class="xref py py-meth docutils literal"><span class="pre">new_request()</span></tt></a> method to kick start the
request with remote server/client. For server <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> this
method is usually not implemented and therefore is simply a pass-through.
<strong>For clients this method should be implemented</strong> and it is critical method
where errors caused by stale socket connections can arise.
<strong>This method should not be called directly.</strong> Use <a class="reference internal" href="#pulsar.ProtocolConsumer.new_request" title="pulsar.ProtocolConsumer.new_request"><tt class="xref py py-meth docutils literal"><span class="pre">new_request()</span></tt></a>
instead. Tipically one writes some data from the <a class="reference internal" href="#pulsar.ProtocolConsumer.current_request" title="pulsar.ProtocolConsumer.current_request"><tt class="xref py py-attr docutils literal"><span class="pre">current_request</span></tt></a>
into the transport. Something like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_request</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pulsar.ProtocolConsumer.new_request">
<tt class="descname">new_request</tt><big>(</big><em>request=None</em><big>)</big><a class="headerlink" href="#pulsar.ProtocolConsumer.new_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Starts a new <tt class="docutils literal"><span class="pre">request</span></tt> for this protocol consumer if
<a class="reference internal" href="#pulsar.ProtocolConsumer.connected" title="pulsar.ProtocolConsumer.connected"><tt class="xref py py-attr docutils literal"><span class="pre">connected</span></tt></a> or <a class="reference internal" href="#pulsar.ProtocolConsumer.connecting" title="pulsar.ProtocolConsumer.connecting"><tt class="xref py py-attr docutils literal"><span class="pre">connecting</span></tt></a> is <cite>True</cite>. There is no need to
override this method, implement <a class="reference internal" href="#pulsar.ProtocolConsumer.start_request" title="pulsar.ProtocolConsumer.start_request"><tt class="xref py py-meth docutils literal"><span class="pre">start_request()</span></tt></a> instead.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.ProtocolConsumer.reset_connection">
<tt class="descname">reset_connection</tt><big>(</big><big>)</big><a class="headerlink" href="#pulsar.ProtocolConsumer.reset_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Cleanly dispose of the current <a class="reference internal" href="#pulsar.ProtocolConsumer.connection" title="pulsar.ProtocolConsumer.connection"><tt class="xref py py-attr docutils literal"><span class="pre">connection</span></tt></a>. Used
by client consumers only.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.ProtocolConsumer.finished">
<tt class="descname">finished</tt><big>(</big><em>result=&lt;object object at 0x10b9e0170&gt;</em><big>)</big><a class="headerlink" href="#pulsar.ProtocolConsumer.finished" title="Permalink to this definition">¶</a></dt>
<dd><p>Call this method when done with this <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a>.
By default it calls the <a class="reference internal" href="#pulsar.Connection.finished" title="pulsar.Connection.finished"><tt class="xref py py-meth docutils literal"><span class="pre">Connection.finished()</span></tt></a> method of the
<a class="reference internal" href="#pulsar.ProtocolConsumer.connection" title="pulsar.ProtocolConsumer.connection"><tt class="xref py py-attr docutils literal"><span class="pre">connection</span></tt></a> attribute.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="producer">
<h2>Producer<a class="headerlink" href="#producer" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pulsar.Producer">
<em class="property">class </em><tt class="descclassname">pulsar.</tt><tt class="descname">Producer</tt><big>(</big><em>max_connections=0</em>, <em>timeout=0</em>, <em>connection_factory=None</em><big>)</big><a class="headerlink" href="#pulsar.Producer" title="Permalink to this definition">¶</a></dt>
<dd><p>A Producer of <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> with remote servers or clients.
It is the base class for both <a class="reference internal" href="#pulsar.Server" title="pulsar.Server"><tt class="xref py py-class docutils literal"><span class="pre">Server</span></tt></a> and <a class="reference internal" href="#pulsar.ConnectionPool" title="pulsar.ConnectionPool"><tt class="xref py py-class docutils literal"><span class="pre">ConnectionPool</span></tt></a>.
The main method in this class is <a class="reference internal" href="#pulsar.Producer.new_connection" title="pulsar.Producer.new_connection"><tt class="xref py py-meth docutils literal"><span class="pre">new_connection()</span></tt></a> where a new
<a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> is created and added to the set of
<a class="reference internal" href="#pulsar.Producer.concurrent_connections" title="pulsar.Producer.concurrent_connections"><tt class="xref py py-attr docutils literal"><span class="pre">concurrent_connections</span></tt></a>.</p>
<dl class="attribute">
<dt id="pulsar.Producer.connection_factory">
<tt class="descname">connection_factory</tt><a class="headerlink" href="#pulsar.Producer.connection_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>A factory producing the <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> from a
remote client with this producer.
This attribute is used in the <a class="reference internal" href="#pulsar.Producer.new_connection" title="pulsar.Producer.new_connection"><tt class="xref py py-meth docutils literal"><span class="pre">new_connection()</span></tt></a> method.
There shouldn&#8217;t be any reason to change the default <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a>,
it is here just in case.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Producer.concurrent_connections">
<tt class="descname">concurrent_connections</tt><a class="headerlink" href="#pulsar.Producer.concurrent_connections" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of concurrent active connections</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Producer.received">
<tt class="descname">received</tt><a class="headerlink" href="#pulsar.Producer.received" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of received connections</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Producer.timeout">
<tt class="descname">timeout</tt><a class="headerlink" href="#pulsar.Producer.timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>number of seconds to keep alive an idle connection</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Producer.max_connections">
<tt class="descname">max_connections</tt><a class="headerlink" href="#pulsar.Producer.max_connections" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum number of connections allowed. A value of 0 (default)
means no limit.</p>
</dd></dl>

<dl class="attribute">
<dt>
<tt class="descname">connection_factory</tt></dt>
<dd><p>alias of <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Producer.new_connection">
<tt class="descname">new_connection</tt><big>(</big><em>address</em>, <em>consumer_factory</em>, <em>producer=None</em><big>)</big><a class="headerlink" href="#pulsar.Producer.new_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when a new <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> is created. The <em>producer</em>
is either a <a class="reference internal" href="#pulsar.Server" title="pulsar.Server"><tt class="xref py py-class docutils literal"><span class="pre">Server</span></tt></a> or a <a class="reference internal" href="#pulsar.Client" title="pulsar.Client"><tt class="xref py py-class docutils literal"><span class="pre">Client</span></tt></a>. If the number of
<a class="reference internal" href="#pulsar.Producer.concurrent_connections" title="pulsar.Producer.concurrent_connections"><tt class="xref py py-attr docutils literal"><span class="pre">concurrent_connections</span></tt></a> is greater or equal <a class="reference internal" href="#pulsar.Producer.max_connections" title="pulsar.Producer.max_connections"><tt class="xref py py-attr docutils literal"><span class="pre">max_connections</span></tt></a>
a <tt class="xref py py-class docutils literal"><span class="pre">RuntimeError</span></tt> is raised.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Producer.close_connections">
<tt class="descname">close_connections</tt><big>(</big><em>connection=None</em>, <em>async=True</em><big>)</big><a class="headerlink" href="#pulsar.Producer.close_connections" title="Permalink to this definition">¶</a></dt>
<dd><p>Close <em>connection</em> if specified, otherwise close all
active connections.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="clients">
<h2>Clients<a class="headerlink" href="#clients" title="Permalink to this headline">¶</a></h2>
<p>This section introduces two classes for transport/protocol clients with several
connections to a remote <a class="reference internal" href="#pulsar.Server" title="pulsar.Server"><tt class="xref py py-class docutils literal"><span class="pre">Server</span></tt></a>.</p>
<div class="section" id="client">
<h3>Client<a class="headerlink" href="#client" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pulsar.Client">
<em class="property">class </em><tt class="descclassname">pulsar.</tt><tt class="descname">Client</tt><big>(</big><em>max_connections=None</em>, <em>timeout=None</em>, <em>client_version=None</em>, <em>trust_env=True</em>, <em>consumer_factory=None</em>, <em>max_reconnect=None</em>, <em>force_sync=False</em>, <em>event_loop=None</em>, <em>**params</em><big>)</big><a class="headerlink" href="#pulsar.Client" title="Permalink to this definition">¶</a></dt>
<dd><p>A client for a remote server which handles one or more
<a class="reference internal" href="#pulsar.ConnectionPool" title="pulsar.ConnectionPool"><tt class="xref py py-class docutils literal"><span class="pre">ConnectionPool</span></tt></a> of asynchronous connections.
It has the <tt class="docutils literal"><span class="pre">finish</span></tt> <a class="reference internal" href="../tutorials/events.html#one-time-event"><em>one time event</em></a> fired when calling
the <a class="reference internal" href="#pulsar.Client.close" title="pulsar.Client.close"><tt class="xref py py-meth docutils literal"><span class="pre">close()</span></tt></a> method, four <a class="reference internal" href="../tutorials/events.html#many-times-event"><em>many time events</em></a>
which can be used to add additional information to the request to send
to the remote server and to postprocess responses. These events are:
<tt class="docutils literal"><span class="pre">connection_made</span></tt>, <tt class="docutils literal"><span class="pre">pre_request</span></tt>, <tt class="docutils literal"><span class="pre">post_request</span></tt>, <tt class="docutils literal"><span class="pre">connection_lost</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>max_connections</strong> &#8211; Optional maximum number of connections.</li>
<li><strong>timeout</strong> &#8211; Optional timeout in seconds for closing idle connections.</li>
<li><strong>force_sync</strong> &#8211; set the <a class="reference internal" href="#pulsar.Client.force_sync" title="pulsar.Client.force_sync"><tt class="xref py py-attr docutils literal"><span class="pre">force_sync</span></tt></a> attribute.</li>
<li><strong>event_loop</strong> &#8211; Optional <a class="reference internal" href="async.html#pulsar.EventLoop" title="pulsar.EventLoop"><tt class="xref py py-class docutils literal"><span class="pre">EventLoop</span></tt></a> which set the <a class="reference internal" href="#pulsar.Client.event_loop" title="pulsar.Client.event_loop"><tt class="xref py py-attr docutils literal"><span class="pre">event_loop</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pulsar.Client.event_loop">
<tt class="descname">event_loop</tt><a class="headerlink" href="#pulsar.Client.event_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="async.html#pulsar.EventLoop" title="pulsar.EventLoop"><tt class="xref py py-class docutils literal"><span class="pre">EventLoop</span></tt></a> for this <a class="reference internal" href="#pulsar.Client" title="pulsar.Client"><tt class="xref py py-class docutils literal"><span class="pre">Client</span></tt></a>. Can be <tt class="docutils literal"><span class="pre">None</span></tt>.
The preferred way to obtain the event loop is via the <a class="reference internal" href="#pulsar.Client.get_event_loop" title="pulsar.Client.get_event_loop"><tt class="xref py py-meth docutils literal"><span class="pre">get_event_loop()</span></tt></a>
method rather than accessing this attribute directly.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Client.force_sync">
<tt class="descname">force_sync</tt><a class="headerlink" href="#pulsar.Client.force_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>Force a synchronous client, that is a client which has it
own <a class="reference internal" href="async.html#pulsar.EventLoop" title="pulsar.EventLoop"><tt class="xref py py-class docutils literal"><span class="pre">EventLoop</span></tt></a> and blocks until a response is available.</p>
<p>Default: <cite>False</cite></p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Client.connection_pool">
<tt class="descname">connection_pool</tt><a class="headerlink" href="#pulsar.Client.connection_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory of <a class="reference internal" href="#pulsar.ConnectionPool" title="pulsar.ConnectionPool"><tt class="xref py py-class docutils literal"><span class="pre">ConnectionPool</span></tt></a>.</p>
<p>alias of <a class="reference internal" href="#pulsar.ConnectionPool" title="pulsar.ConnectionPool"><tt class="xref py py-class docutils literal"><span class="pre">ConnectionPool</span></tt></a></p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Client.connection_factory">
<tt class="descname">connection_factory</tt><em class="property"> = None</em><a class="headerlink" href="#pulsar.Client.connection_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>A factory of <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Client.reconnecting_gap">
<tt class="descname">reconnecting_gap</tt><em class="property"> = 2</em><a class="headerlink" href="#pulsar.Client.reconnecting_gap" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconnecting gap in seconds.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Client.client_version">
<tt class="descname">client_version</tt><em class="property"> = ''</em><a class="headerlink" href="#pulsar.Client.client_version" title="Permalink to this definition">¶</a></dt>
<dd><p>An optional version for this client</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Client.timeout">
<tt class="descname">timeout</tt><em class="property"> = 0</em><a class="headerlink" href="#pulsar.Client.timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Optional timeout in seconds for idle connections.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Client.consumer_factory">
<tt class="descname">consumer_factory</tt><em class="property"> = None</em><a class="headerlink" href="#pulsar.Client.consumer_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>A factory of <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> for sending and consuming data.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Client.max_connections">
<tt class="descname">max_connections</tt><em class="property"> = 0</em><a class="headerlink" href="#pulsar.Client.max_connections" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum number of concurrent connections.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Client.connection_pools">
<tt class="descname">connection_pools</tt><em class="property"> = None</em><a class="headerlink" href="#pulsar.Client.connection_pools" title="Permalink to this definition">¶</a></dt>
<dd><p>Dictionar of <a class="reference internal" href="#pulsar.ConnectionPool" title="pulsar.ConnectionPool"><tt class="xref py py-class docutils literal"><span class="pre">ConnectionPool</span></tt></a>. If initialized at class level it
will remain as a class attribute, otherwise it will be an instance attribute.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Client.max_reconnect">
<tt class="descname">max_reconnect</tt><em class="property"> = 1</em><a class="headerlink" href="#pulsar.Client.max_reconnect" title="Permalink to this definition">¶</a></dt>
<dd><p>Can reconnect on socket error.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Client.setup">
<tt class="descname">setup</tt><big>(</big><em>**params</em><big>)</big><a class="headerlink" href="#pulsar.Client.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup the client. By default it does nothing.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Client.concurrent_connections">
<tt class="descname">concurrent_connections</tt><a class="headerlink" href="#pulsar.Client.concurrent_connections" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of concurrent connections.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Client.available_connections">
<tt class="descname">available_connections</tt><a class="headerlink" href="#pulsar.Client.available_connections" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of available connections.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Client.closed">
<tt class="descname">closed</tt><a class="headerlink" href="#pulsar.Client.closed" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">True</span></tt> if the <a class="reference internal" href="#pulsar.Client.close" title="pulsar.Client.close"><tt class="xref py py-meth docutils literal"><span class="pre">close()</span></tt></a> was invoked on this <a class="reference internal" href="#pulsar.Client" title="pulsar.Client"><tt class="xref py py-class docutils literal"><span class="pre">Client</span></tt></a>.
A closed <a class="reference internal" href="#pulsar.Client" title="pulsar.Client"><tt class="xref py py-class docutils literal"><span class="pre">Client</span></tt></a> cannot send <a class="reference internal" href="#pulsar.Client.request" title="pulsar.Client.request"><tt class="xref py py-meth docutils literal"><span class="pre">request()</span></tt></a> to remote servers.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Client.get_event_loop">
<tt class="descname">get_event_loop</tt><big>(</big><big>)</big><a class="headerlink" href="#pulsar.Client.get_event_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <a class="reference internal" href="async.html#pulsar.EventLoop" title="pulsar.EventLoop"><tt class="xref py py-class docutils literal"><span class="pre">EventLoop</span></tt></a> used by this <a class="reference internal" href="#pulsar.Client" title="pulsar.Client"><tt class="xref py py-class docutils literal"><span class="pre">Client</span></tt></a>.
The event loop can be set during initialisation. If <a class="reference internal" href="#pulsar.Client.force_sync" title="pulsar.Client.force_sync"><tt class="xref py py-attr docutils literal"><span class="pre">force_sync</span></tt></a>
is <tt class="docutils literal"><span class="pre">True</span></tt> a specialised event loop is created.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Client.request">
<tt class="descname">request</tt><big>(</big><em>*args</em>, <em>**params</em><big>)</big><a class="headerlink" href="#pulsar.Client.request" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method for creating a request to send to the server.
<strong>Must be implemented by subclasses</strong>. The method should return a
<a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> via invoking the <a class="reference internal" href="#pulsar.Client.response" title="pulsar.Client.response"><tt class="xref py py-meth docutils literal"><span class="pre">response()</span></tt></a> method.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Client.response">
<tt class="descname">response</tt><big>(</big><em>request</em>, <em>response=None</em>, <em>new_connection=True</em><big>)</big><a class="headerlink" href="#pulsar.Client.response" title="Permalink to this definition">¶</a></dt>
<dd><p>Once a <tt class="docutils literal"><span class="pre">request</span></tt> object has been constructed, the <a class="reference internal" href="#pulsar.Client.request" title="pulsar.Client.request"><tt class="xref py py-meth docutils literal"><span class="pre">request()</span></tt></a>
method can invoke this method to build the <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> and
start the response. There should not be any reason to override this method.
This method is run on this client event loop (obtained via the
<a class="reference internal" href="#pulsar.Client.get_event_loop" title="pulsar.Client.get_event_loop"><tt class="xref py py-meth docutils literal"><span class="pre">get_event_loop()</span></tt></a> method) thread.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>request</strong> &#8211; A custom <tt class="xref py py-class docutils literal"><span class="pre">Request</span></tt> for the <a class="reference internal" href="#pulsar.Client" title="pulsar.Client"><tt class="xref py py-class docutils literal"><span class="pre">Client</span></tt></a>.</li>
<li><strong>response</strong> &#8211; A <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> to reuse, otherwise
<tt class="docutils literal"><span class="pre">None</span></tt> (Default).</li>
<li><strong>new_connection</strong> &#8211; <tt class="docutils literal"><span class="pre">True</span></tt> if a new connection is required via
the <a class="reference internal" href="#pulsar.Client.get_connection" title="pulsar.Client.get_connection"><tt class="xref py py-meth docutils literal"><span class="pre">get_connection()</span></tt></a> method. Default <tt class="docutils literal"><span class="pre">True</span></tt>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">An <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> obtained form
<a class="reference internal" href="#pulsar.Client.consumer_factory" title="pulsar.Client.consumer_factory"><tt class="xref py py-attr docutils literal"><span class="pre">consumer_factory</span></tt></a>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pulsar.Client.get_connection">
<tt class="descname">get_connection</tt><big>(</big><em>request</em><big>)</big><a class="headerlink" href="#pulsar.Client.get_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a suitable <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> for <em>request</em>.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Client.update_parameters">
<tt class="descname">update_parameters</tt><big>(</big><em>parameter_list</em>, <em>params</em><big>)</big><a class="headerlink" href="#pulsar.Client.update_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Update <em>param</em> with attributes of this <a class="reference internal" href="#pulsar.Client" title="pulsar.Client"><tt class="xref py py-class docutils literal"><span class="pre">Client</span></tt></a> defined
in <tt class="xref py py-attr docutils literal"><span class="pre">request_parameters</span></tt> tuple.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Client.close_connections">
<tt class="descname">close_connections</tt><big>(</big><em>async=True</em><big>)</big><a class="headerlink" href="#pulsar.Client.close_connections" title="Permalink to this definition">¶</a></dt>
<dd><p>Close all connections in each <a class="reference internal" href="#pulsar.Client.connection_pools" title="pulsar.Client.connection_pools"><tt class="xref py py-attr docutils literal"><span class="pre">connection_pools</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Client.close">
<tt class="descname">close</tt><big>(</big><em>async=True</em><big>)</big><a class="headerlink" href="#pulsar.Client.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close all connections and fire the <tt class="docutils literal"><span class="pre">finish</span></tt>
<a class="reference internal" href="../tutorials/events.html#one-time-event"><em>one time event</em></a></p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Client.can_reuse_connection">
<tt class="descname">can_reuse_connection</tt><big>(</big><em>connection</em>, <em>response</em><big>)</big><a class="headerlink" href="#pulsar.Client.can_reuse_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoked by the <a class="reference internal" href="#pulsar.ConnectionPool.release_connection" title="pulsar.ConnectionPool.release_connection"><tt class="xref py py-meth docutils literal"><span class="pre">ConnectionPool.release_connection()</span></tt></a>, it checks
whether the <em>connection</em> can be reused in the future or it must be disposed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>connection</strong> &#8211; the <a class="reference internal" href="#pulsar.Connection" title="pulsar.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> to check.</li>
<li><strong>response</strong> &#8211; the <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> which last consumed the incoming
data from the connection (it can be <tt class="docutils literal"><span class="pre">None</span></tt>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><tt class="docutils literal"><span class="pre">True</span></tt> or <tt class="docutils literal"><span class="pre">False</span></tt>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pulsar.Client.upgrade">
<tt class="descname">upgrade</tt><big>(</big><em>connection</em>, <em>protocol_factory</em>, <em>result=None</em><big>)</big><a class="headerlink" href="#pulsar.Client.upgrade" title="Permalink to this definition">¶</a></dt>
<dd><p>Upgrade an existing connection with a new protocol factory.
Return the upgraded connection only if the <a class="reference internal" href="#pulsar.Connection.current_consumer" title="pulsar.Connection.current_consumer"><tt class="xref py py-attr docutils literal"><span class="pre">Connection.current_consumer</span></tt></a>
is available.</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Client.timeit">
<tt class="descname">timeit</tt><big>(</big><em>times</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pulsar.Client.timeit" title="Permalink to this definition">¶</a></dt>
<dd><p>Send <em>times</em> requests asynchronously and evaluate the time
taken to obtain all responses.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="client-connection-pool">
<h3>Client Connection Pool<a class="headerlink" href="#client-connection-pool" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pulsar.ConnectionPool">
<em class="property">class </em><tt class="descclassname">pulsar.</tt><tt class="descname">ConnectionPool</tt><big>(</big><em>request</em>, <em>**params</em><big>)</big><a class="headerlink" href="#pulsar.ConnectionPool" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="#pulsar.Producer" title="pulsar.Producer"><tt class="xref py py-class docutils literal"><span class="pre">Producer</span></tt></a> of of active connections for client
protocols. It maintains a live set of connections.</p>
<dl class="attribute">
<dt id="pulsar.ConnectionPool.address">
<tt class="descname">address</tt><a class="headerlink" href="#pulsar.ConnectionPool.address" title="Permalink to this definition">¶</a></dt>
<dd><p>Address to connect to</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.ConnectionPool.release_connection">
<tt class="descname">release_connection</tt><big>(</big><em>connection</em>, <em>response=None</em><big>)</big><a class="headerlink" href="#pulsar.ConnectionPool.release_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Releases the <em>connection</em> back to the pool. This function remove
the <em>connection</em> from the set of concurrent connections and add it to the set
of available connections.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>connection</strong> &#8211; The connection to release</li>
<li><strong>response</strong> &#8211; Optional <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> which consumed the
connection.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pulsar.ConnectionPool.get_or_create_connection">
<tt class="descname">get_or_create_connection</tt><big>(</big><em>client</em><big>)</big><a class="headerlink" href="#pulsar.ConnectionPool.get_or_create_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Get or create a new connection for <em>client</em></p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="server">
<h2>Server<a class="headerlink" href="#server" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pulsar.Server">
<em class="property">class </em><tt class="descclassname">pulsar.</tt><tt class="descname">Server</tt><big>(</big><em>consumer_factory=None</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pulsar.Server" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference internal" href="#pulsar.Producer" title="pulsar.Producer"><tt class="xref py py-class docutils literal"><span class="pre">Producer</span></tt></a> for all server&#8217;s listening for connections.
It is a producer of <a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a> for server protocols.</p>
<dl class="attribute">
<dt>
<tt class="descname">transport:</tt></dt>
<dd><p>The <a class="reference internal" href="#pulsar.Transport" title="pulsar.Transport"><tt class="xref py py-class docutils literal"><span class="pre">Transport</span></tt></a> listening for client connections.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Server.consumer_factory">
<tt class="descname">consumer_factory</tt><a class="headerlink" href="#pulsar.Server.consumer_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>Callable or a <a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> class for producing
<a class="reference internal" href="#pulsar.ProtocolConsumer" title="pulsar.ProtocolConsumer"><tt class="xref py py-class docutils literal"><span class="pre">ProtocolConsumer</span></tt></a> which handle the receiving, decoding and
sending of data.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Server.event_loop">
<tt class="descname">event_loop</tt><a class="headerlink" href="#pulsar.Server.event_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="async.html#pulsar.EventLoop" title="pulsar.EventLoop"><tt class="xref py py-class docutils literal"><span class="pre">EventLoop</span></tt></a> running the server.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Server.address">
<tt class="descname">address</tt><a class="headerlink" href="#pulsar.Server.address" title="Permalink to this definition">¶</a></dt>
<dd><p>Server address, where clients send requests to.</p>
</dd></dl>

<dl class="attribute">
<dt id="pulsar.Server.timeout">
<tt class="descname">timeout</tt><a class="headerlink" href="#pulsar.Server.timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>A timeout in seconds for idle connections</p>
</dd></dl>

<dl class="method">
<dt id="pulsar.Server.data_received">
<tt class="descname">data_received</tt><big>(</big><em>sock</em>, <em>address</em><big>)</big><a class="headerlink" href="#pulsar.Server.data_received" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new server <a class="reference internal" href="#pulsar.Protocol" title="pulsar.Protocol"><tt class="xref py py-class docutils literal"><span class="pre">Protocol</span></tt></a> ready to serve its client.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pulsar.Server.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>event_loop</em>, <em>sock=None</em>, <em>address=None</em>, <em>backlog=1024</em>, <em>name=None</em>, <em>close_event_loop=None</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#pulsar.Server.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new server!</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper"><p class="logo">
<a href="../index.html">
  <img class="logo" width="200" src="../static/pulsar.png" alt="pulsar" title="Pulsar"/>
</a>
</p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Protocols API</a><ul>
<li><a class="reference internal" href="#transport">Transport</a></li>
<li><a class="reference internal" href="#protocol">Protocol</a></li>
<li><a class="reference internal" href="#connection">Connection</a></li>
<li><a class="reference internal" href="#protocol-consumer">Protocol Consumer</a></li>
<li><a class="reference internal" href="#producer">Producer</a></li>
<li><a class="reference internal" href="#clients">Clients</a><ul>
<li><a class="reference internal" href="#client">Client</a></li>
<li><a class="reference internal" href="#client-connection-pool">Client Connection Pool</a></li>
</ul>
</li>
<li><a class="reference internal" href="#server">Server</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="actor.html"
                        title="previous chapter">Actors API</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="application.html"
                        title="next chapter">Applications API</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../sources/api/protocols.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>

    <div class="footer">
        &copy; Copyright 2011-2013, Luca Sbardella.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
<script type="text/javascript">

  var _gaq = _gaq || [];
  
  _gaq.push(['_setAccount', 'UA-3900561-8']);
  
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

  </body>
</html>